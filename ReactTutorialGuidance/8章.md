## 第8章：データの取得（API連携）

### 8-1. API連携の基本概念

#### 8-1-1. APIとは何か？

**API（Application Programming Interface）**とは、アプリケーション間でデータをやり取りするためのインターフェースです。

**Web APIの種類：**
- **REST API**: HTTPメソッド（GET, POST, PUT, DELETE）を使用
- **GraphQL**: クエリ言語を使用した柔軟なデータ取得
- **WebSocket**: リアルタイム双方向通信

**ReactアプリケーションでのAPI連携：**
```jsx
// フロントエンド（React） ←→ バックエンド（API）
// データの取得・送信・更新・削除
```

#### 8-1-2. HTTPメソッドの基本

| メソッド | 用途 | 例 |
|---------|------|-----|
| GET | データの取得 | ユーザー一覧の取得 |
| POST | データの作成 | 新規ユーザーの登録 |
| PUT | データの更新（全体） | ユーザー情報の完全更新 |
| PATCH | データの更新（部分） | ユーザー名のみ更新 |
| DELETE | データの削除 | ユーザーの削除 |

### 8-2. `fetch`を使ったAPI呼び出し

#### 8-2-1. 基本的なGETリクエスト

```jsx
import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch('https://api.example.com/users');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
        console.error('データ取得エラー:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <div>
      <h2>ユーザー一覧</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>
            <h3>{user.name}</h3>
            <p>Email: {user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### 8-2-2. POSTリクエスト（データの作成）

```jsx
import { useState } from 'react';

function UserForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    role: 'user'
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      setLoading(true);
      setError(null);
      setSuccess(false);

      const response = await fetch('https://api.example.com/users', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const newUser = await response.json();
      console.log('作成されたユーザー:', newUser);
      setSuccess(true);
      
      // フォームをリセット
      setFormData({ name: '', email: '', role: 'user' });
    } catch (err) {
      setError(err.message);
      console.error('ユーザー作成エラー:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  return (
    <div>
      <h2>新規ユーザー登録</h2>
      
      {error && <div style={{ color: 'red' }}>エラー: {error}</div>}
      {success && <div style={{ color: 'green' }}>ユーザーが正常に作成されました！</div>}
      
      <form onSubmit={handleSubmit}>
        <div>
          <label>名前:</label>
          <input
            type="text"
            name="name"
            value={formData.name}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>メールアドレス:</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>役職:</label>
          <select
            name="role"
            value={formData.role}
            onChange={handleChange}
          >
            <option value="user">一般ユーザー</option>
            <option value="admin">管理者</option>
            <option value="moderator">モデレーター</option>
          </select>
        </div>
        
        <button type="submit" disabled={loading}>
          {loading ? '作成中...' : 'ユーザーを作成'}
        </button>
      </form>
    </div>
  );
}
```

#### 8-2-3. PUT/PATCHリクエスト（データの更新）

```jsx
import { useState, useEffect } from 'react';

function UserEdit({ userId }) {
  const [user, setUser] = useState(null);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    role: ''
  });
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);

  // ユーザーデータの取得
  useEffect(() => {
    const fetchUser = async () => {
      try {
        const response = await fetch(`https://api.example.com/users/${userId}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const userData = await response.json();
        setUser(userData);
        setFormData({
          name: userData.name,
          email: userData.email,
          role: userData.role
        });
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]);

  // ユーザーデータの更新
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      setSaving(true);
      setError(null);
      setSuccess(false);

      const response = await fetch(`https://api.example.com/users/${userId}`, {
        method: 'PUT', // または 'PATCH'
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const updatedUser = await response.json();
      setUser(updatedUser);
      setSuccess(true);
    } catch (err) {
      setError(err.message);
    } finally {
      setSaving(false);
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;
  if (!user) return <div>ユーザーが見つかりません</div>;

  return (
    <div>
      <h2>ユーザー編集</h2>
      
      {error && <div style={{ color: 'red' }}>エラー: {error}</div>}
      {success && <div style={{ color: 'green' }}>更新が完了しました！</div>}
      
      <form onSubmit={handleSubmit}>
        <div>
          <label>名前:</label>
          <input
            type="text"
            name="name"
            value={formData.name}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>メールアドレス:</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            required
          />
        </div>
        
        <div>
          <label>役職:</label>
          <select
            name="role"
            value={formData.role}
            onChange={handleChange}
          >
            <option value="user">一般ユーザー</option>
            <option value="admin">管理者</option>
            <option value="moderator">モデレーター</option>
          </select>
        </div>
        
        <button type="submit" disabled={saving}>
          {saving ? '更新中...' : '更新'}
        </button>
      </form>
    </div>
  );
}
```

#### 8-2-4. DELETEリクエスト（データの削除）

```jsx
import { useState } from 'react';

function UserDelete({ userId, onDelete }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleDelete = async () => {
    if (!window.confirm('本当にこのユーザーを削除しますか？')) {
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const response = await fetch(`https://api.example.com/users/${userId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      // 親コンポーネントに削除完了を通知
      onDelete(userId);
    } catch (err) {
      setError(err.message);
      console.error('削除エラー:', err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      {error && <div style={{ color: 'red' }}>エラー: {error}</div>}
      
      <button 
        onClick={handleDelete} 
        disabled={loading}
        style={{ backgroundColor: 'red', color: 'white' }}
      >
        {loading ? '削除中...' : '削除'}
      </button>
    </div>
  );
}
```

### 8-3. `axios`を使ったAPI呼び出し

#### 8-3-1. axiosのインストールとセットアップ

```bash
# npmを使用する場合
npm install axios

# yarnを使用する場合
yarn add axios

# pnpmを使用する場合
pnpm add axios
```

#### 8-3-2. 基本的なaxiosの使用

```jsx
import axios from 'axios';
import { useState, useEffect } from 'react';

function UserListWithAxios() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await axios.get('https://api.example.com/users');
        setUsers(response.data);
      } catch (err) {
        setError(err.response?.data?.message || err.message);
        console.error('データ取得エラー:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <div>
      <h2>ユーザー一覧（axios使用）</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>
            <h3>{user.name}</h3>
            <p>Email: {user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### 8-3-3. axiosの設定とインターセプター

```jsx
// api/axios.js
import axios from 'axios';

// ベースURLの設定
const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000, // 10秒でタイムアウト
  headers: {
    'Content-Type': 'application/json',
  }
});

// リクエストインターセプター
api.interceptors.request.use(
  (config) => {
    // 認証トークンを自動的に追加
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// レスポンスインターセプター
api.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    // 401エラーの場合はログインページにリダイレクト
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;

// 使用例
import api from './api/axios';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const response = await api.get('/users');
        setUsers(response.data);
      } catch (error) {
        console.error('エラー:', error);
      }
    };

    fetchUsers();
  }, []);

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 8-4. カスタムフックでのAPI管理

#### 8-4-1. 基本的なAPIフック

```jsx
import { useState, useEffect } from 'react';

// 汎用的なAPI呼び出しフック
function useApi(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [url]);

  const refetch = () => {
    fetchData();
  };

  return { data, loading, error, refetch };
}

// 使用例
function UserList() {
  const { data: users, loading, error, refetch } = useApi('https://api.example.com/users');

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <div>
      <h2>ユーザー一覧</h2>
      <button onClick={refetch}>再読み込み</button>
      <ul>
        {users?.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### 8-4-2. CRUD操作のカスタムフック

```jsx
import { useState, useCallback } from 'react';

// CRUD操作のカスタムフック
function useCrud(baseUrl) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const create = useCallback(async (data) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [baseUrl]);

  const read = useCallback(async (id) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`${baseUrl}/${id}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [baseUrl]);

  const update = useCallback(async (id, data) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`${baseUrl}/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [baseUrl]);

  const remove = useCallback(async (id) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`${baseUrl}/${id}`, {
        method: 'DELETE'
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return true;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [baseUrl]);

  return {
    create,
    read,
    update,
    remove,
    loading,
    error
  };
}

// 使用例
function UserManagement() {
  const { create, read, update, remove, loading, error } = useCrud('https://api.example.com/users');
  const [users, setUsers] = useState([]);

  const handleCreate = async (userData) => {
    try {
      const newUser = await create(userData);
      setUsers(prev => [...prev, newUser]);
    } catch (err) {
      console.error('作成エラー:', err);
    }
  };

  const handleUpdate = async (id, userData) => {
    try {
      const updatedUser = await update(id, userData);
      setUsers(prev => prev.map(user => 
        user.id === id ? updatedUser : user
      ));
    } catch (err) {
      console.error('更新エラー:', err);
    }
  };

  const handleDelete = async (id) => {
    try {
      await remove(id);
      setUsers(prev => prev.filter(user => user.id !== id));
    } catch (err) {
      console.error('削除エラー:', err);
    }
  };

  return (
    <div>
      {error && <div style={{ color: 'red' }}>エラー: {error}</div>}
      {loading && <div>処理中...</div>}
      
      {/* ユーザー管理UI */}
    </div>
  );
}
```

### 8-5. エラーハンドリングとリトライ機能

#### 8-5-1. 高度なエラーハンドリング

```jsx
import { useState, useCallback } from 'react';

// リトライ機能付きAPI呼び出し
function useApiWithRetry(url, maxRetries = 3) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);

  const fetchWithRetry = useCallback(async (retryAttempt = 0) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const result = await response.json();
      setData(result);
      setRetryCount(0);
    } catch (err) {
      if (retryAttempt < maxRetries) {
        // 指数バックオフでリトライ
        const delay = Math.pow(2, retryAttempt) * 1000;
        setTimeout(() => {
          setRetryCount(retryAttempt + 1);
          fetchWithRetry(retryAttempt + 1);
        }, delay);
      } else {
        setError(err.message);
        setRetryCount(0);
      }
    } finally {
      setLoading(false);
    }
  }, [url, maxRetries]);

  const retry = useCallback(() => {
    fetchWithRetry();
  }, [fetchWithRetry]);

  return { data, loading, error, retry, retryCount };
}

// 使用例
function UserListWithRetry() {
  const { data: users, loading, error, retry, retryCount } = useApiWithRetry('https://api.example.com/users');

  if (loading) {
    return (
      <div>
        読み込み中...
        {retryCount > 0 && <p>リトライ中... ({retryCount}/3)</p>}
      </div>
    );
  }

  if (error) {
    return (
      <div>
        <p>エラー: {error}</p>
        <button onClick={retry}>再試行</button>
      </div>
    );
  }

  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

#### 8-5-2. グローバルエラーハンドリング

```jsx
// utils/errorHandler.js
export class ApiError extends Error {
  constructor(message, status, data = null) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.data = data;
  }
}

export function handleApiError(error) {
  if (error instanceof ApiError) {
    switch (error.status) {
      case 400:
        return 'リクエストが正しくありません';
      case 401:
        return '認証が必要です';
      case 403:
        return 'アクセスが拒否されました';
      case 404:
        return 'リソースが見つかりません';
      case 500:
        return 'サーバーエラーが発生しました';
      default:
        return error.message;
    }
  }
  
  if (error.name === 'TypeError' && error.message.includes('fetch')) {
    return 'ネットワークエラーが発生しました';
  }
  
  return '予期しないエラーが発生しました';
}

// 使用例
function UserList() {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const response = await fetch('https://api.example.com/users');
        
        if (!response.ok) {
          throw new ApiError('ユーザー取得に失敗しました', response.status);
        }
        
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        const errorMessage = handleApiError(err);
        setError(errorMessage);
      }
    };

    fetchUsers();
  }, []);

  if (error) {
    return <div>エラー: {error}</div>;
  }

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 8-6. キャッシュとパフォーマンス最適化

#### 8-6-1. 基本的なキャッシュ機能

```jsx
import { useState, useEffect, useRef } from 'react';

// キャッシュ機能付きAPIフック
function useCachedApi(url, cacheTime = 5 * 60 * 1000) { // デフォルト5分
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const cacheRef = useRef(new Map());

  useEffect(() => {
    const fetchData = async () => {
      const now = Date.now();
      const cached = cacheRef.current.get(url);

      // キャッシュが有効な場合はキャッシュを使用
      if (cached && (now - cached.timestamp) < cacheTime) {
        setData(cached.data);
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        // キャッシュに保存
        cacheRef.current.set(url, {
          data: result,
          timestamp: now
        });
        
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url, cacheTime]);

  const invalidateCache = () => {
    cacheRef.current.delete(url);
  };

  return { data, loading, error, invalidateCache };
}

// 使用例
function UserListWithCache() {
  const { data: users, loading, error, invalidateCache } = useCachedApi('https://api.example.com/users');

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <div>
      <h2>ユーザー一覧（キャッシュ付き）</h2>
      <button onClick={invalidateCache}>キャッシュをクリア</button>
      <ul>
        {users?.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### 8-6-2. 無限スクロールとページネーション

```jsx
import { useState, useEffect, useCallback } from 'react';

// 無限スクロール用のフック
function useInfiniteScroll(url, pageSize = 10) {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);

  const fetchData = useCallback(async (pageNum) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`${url}?page=${pageNum}&limit=${pageSize}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const result = await response.json();
      
      if (pageNum === 1) {
        setData(result.data);
      } else {
        setData(prev => [...prev, ...result.data]);
      }
      
      setHasMore(result.data.length === pageSize);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url, pageSize]);

  const loadMore = useCallback(() => {
    if (!loading && hasMore) {
      const nextPage = page + 1;
      setPage(nextPage);
      fetchData(nextPage);
    }
  }, [loading, hasMore, page, fetchData]);

  useEffect(() => {
    fetchData(1);
  }, [fetchData]);

  return { data, loading, error, hasMore, loadMore };
}

// 使用例
function InfiniteUserList() {
  const { data: users, loading, error, hasMore, loadMore } = useInfiniteScroll('https://api.example.com/users');

  const handleScroll = useCallback((e) => {
    const { scrollTop, scrollHeight, clientHeight } = e.target;
    
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      loadMore();
    }
  }, [loadMore]);

  if (error) return <div>エラー: {error}</div>;

  return (
    <div onScroll={handleScroll} style={{ height: '400px', overflow: 'auto' }}>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      {loading && <div>読み込み中...</div>}
      {!hasMore && <div>すべてのデータを読み込みました</div>}
    </div>
  );
}
```

### 8-7. 実践的な応用例
 [8-7.全体コード例はこちら](全体コード例.md#8-7-1-リアルタイムデータ更新)


### 8-8. まとめ

この章では、ReactアプリケーションでのAPI連携について詳しく学びました：

**重要なポイント：**
1. **APIの基本概念**: HTTPメソッドとREST APIの理解
2. **fetch API**: ネイティブなHTTP通信
3. **axios**: より便利なHTTPクライアント
4. **カスタムフック**: 再利用可能なAPIロジック
5. **エラーハンドリング**: 適切なエラー処理とリトライ機能
6. **パフォーマンス最適化**: キャッシュと無限スクロール

**ベストプラクティス：**
- 適切なエラーハンドリングを実装する
- ローディング状態を管理する
- カスタムフックでロジックを再利用する
- キャッシュを活用してパフォーマンスを向上させる
- セキュリティを考慮したAPI設計を行う

これらの知識を活用して、効率的で保守性の高いReactアプリケーションを構築しましょう。

---
