## 第6章：リストとフォーム

### 6-1. 配列のレンダリング（map）

#### 6-1-1. 基本的な配列のレンダリング

Reactで配列を画面に表示するには、JavaScriptの`map`メソッドを使用します。

```jsx
const fruits = ['りんご', 'バナナ', 'みかん'];

function FruitList() {
  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={index}>{fruit}</li>
      ))}
    </ul>
  );
}
```

**mapメソッドの基本構文：**
```jsx
array.map((item, index) => JSX要素)
```

#### 6-1-2. オブジェクト配列のレンダリング

実際のアプリケーションでは、オブジェクトの配列を扱うことが多いです。

```jsx
const users = [
  { id: 1, name: '田中太郎', age: 25, role: '開発者' },
  { id: 2, name: '佐藤花子', age: 30, role: 'デザイナー' },
  { id: 3, name: '鈴木一郎', age: 28, role: 'プロジェクトマネージャー' }
];

function UserList() {
  return (
    <div>
      <h2>ユーザー一覧</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>
            <h3>{user.name}</h3>
            <p>年齢: {user.age}歳</p>
            <p>役職: {user.role}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### 6-1-3. 条件付きレンダリングとの組み合わせ

配列の要素を条件に応じて表示・非表示にすることもできます。

```jsx
const products = [
  { id: 1, name: 'ノートPC', price: 80000, inStock: true },
  { id: 2, name: 'マウス', price: 3000, inStock: false },
  { id: 3, name: 'キーボード', price: 5000, inStock: true },
  { id: 4, name: 'モニター', price: 25000, inStock: true }
];

function ProductList() {
  return (
    <div>
      <h2>商品一覧</h2>
      <ul>
        {products
          .filter(product => product.inStock) // 在庫がある商品のみフィルタ
          .map(product => (
            <li key={product.id}>
              <h3>{product.name}</h3>
              <p>価格: ¥{product.price.toLocaleString()}</p>
              <span style={{ color: 'green' }}>在庫あり</span>
            </li>
          ))}
      </ul>
    </div>
  );
}
```

### 6-2. `key`属性の重要性

#### 6-2-1. key属性とは？

`key`属性は、Reactがリストの各要素を一意に識別するために使用する特別な属性です。

**なぜkeyが必要？**

Reactは再レンダリング時に、どの要素が変更されたかを正確に把握する必要があります。keyがないと、要素の順序が変わった時に不適切な更新が発生する可能性があります。

#### 6-2-2. key属性の基本ルール

```jsx
// ❌ 悪い例：indexをkeyとして使用
{items.map((item, index) => (
  <li key={index}>{item.name}</li>
))}

// ✅ 良い例：一意のIDをkeyとして使用
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}
```

#### 6-2-3. key属性の選択基準

**推奨されるkey：**
- データベースのID
- UUID
- 一意の文字列

**避けるべきkey：**
- 配列のインデックス（順序が変わる可能性がある場合）
- ランダムな値（毎回レンダリングで変わる）
- 重複する値

```jsx
// 良い例：データベースIDを使用
const posts = [
  { id: 'post-001', title: 'React入門', author: '田中' },
  { id: 'post-002', title: 'JavaScript基礎', author: '佐藤' }
];

// 悪い例：インデックスを使用（順序が変わる可能性がある場合）
const fruits = ['りんご', 'バナナ', 'みかん'];
{fruits.map((fruit, index) => (
  <li key={index}>{fruit}</li> // 順序が変わると問題が発生
))}
```

#### 6-2-4. key属性の問題例と解決方法

**問題例：リストの順序変更**

```jsx
// ❌ 問題のあるコード
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: '買い物', completed: false },
    { id: 2, text: '掃除', completed: false },
    { id: 3, text: '勉強', completed: false }
  ]);

  const moveToTop = (id) => {
    const todo = todos.find(t => t.id === id);
    const others = todos.filter(t => t.id !== id);
    setTodos([todo, ...others]); // 順序を変更
  };

  return (
    <ul>
      {todos.map((todo, index) => (
        <li key={index}> {/* 問題：indexをkeyとして使用 */}
          {todo.text}
          <button onClick={() => moveToTop(todo.id)}>最上部に移動</button>
        </li>
      ))}
    </ul>
  );
}
```

**解決方法：**

```jsx
// ✅ 正しいコード
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: '買い物', completed: false },
    { id: 2, text: '掃除', completed: false },
    { id: 3, text: '勉強', completed: false }
  ]);

  const moveToTop = (id) => {
    const todo = todos.find(t => t.id === id);
    const others = todos.filter(t => t.id !== id);
    setTodos([todo, ...others]);
  };

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}> {/* 解決：一意のIDをkeyとして使用 */}
          {todo.text}
          <button onClick={() => moveToTop(todo.id)}>最上部に移動</button>
        </li>
      ))}
    </ul>
  );
}
```

### 6-3. フォームと`useState`での入力管理

#### 6-3-1. 制御されたコンポーネント（Controlled Components）

Reactでは、フォームの入力値を`useState`で管理することで、入力値を完全に制御できます。

```jsx
import { useState } from 'react';

function SimpleForm() {
  const [input, setInput] = useState('');

  const handleChange = (e) => {
    setInput(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`入力された値: ${input}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="text" 
        value={input} 
        onChange={handleChange}
        placeholder="何か入力してください"
      />
      <button type="submit">送信</button>
    </form>
  );
}
```

**制御されたコンポーネントのポイント：**
- `value={input}`：入力欄の値をReactが制御
- `onChange`：入力されるたびに`setInput`で更新
- `e.preventDefault()`：フォーム送信のページリロードを防ぐ

#### 6-3-2. 複数の入力フィールドの管理

複数の入力フィールドがある場合、オブジェクトで管理すると効率的です。

```jsx
import { useState } from 'react';

function UserForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: '',
    role: '開発者'
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('送信データ:', formData);
    // 実際のAPI呼び出しなど
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>名前:</label>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
          required
        />
      </div>
      
      <div>
        <label>メールアドレス:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          required
        />
      </div>
      
      <div>
        <label>年齢:</label>
        <input
          type="number"
          name="age"
          value={formData.age}
          onChange={handleChange}
          min="0"
          max="120"
        />
      </div>
      
      <div>
        <label>役職:</label>
        <select
          name="role"
          value={formData.role}
          onChange={handleChange}
        >
          <option value="開発者">開発者</option>
          <option value="デザイナー">デザイナー</option>
          <option value="プロジェクトマネージャー">プロジェクトマネージャー</option>
        </select>
      </div>
      
      <button type="submit">登録</button>
    </form>
  );
}
```

#### 6-3-3. フォームバリデーション

入力値の検証（バリデーション）を実装することで、ユーザーに適切なフィードバックを提供できます。

```jsx
import { useState } from 'react';

function ValidatedForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = useState({});
  const [isSubmitted, setIsSubmitted] = useState(false);

  const validateForm = () => {
    const newErrors = {};

    // メールアドレスの検証
    if (!formData.email) {
      newErrors.email = 'メールアドレスは必須です';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = '有効なメールアドレスを入力してください';
    }

    // パスワードの検証
    if (!formData.password) {
      newErrors.password = 'パスワードは必須です';
    } else if (formData.password.length < 6) {
      newErrors.password = 'パスワードは6文字以上で入力してください';
    }

    // パスワード確認の検証
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'パスワードが一致しません';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // リアルタイムバリデーション（オプション）
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validateForm()) {
      console.log('フォーム送信:', formData);
      setIsSubmitted(true);
      // 実際のAPI呼び出しなど
    }
  };

  return (
    <div>
      {isSubmitted ? (
        <div style={{ color: 'green' }}>
          登録が完了しました！
        </div>
      ) : (
        <form onSubmit={handleSubmit}>
          <div>
            <label>メールアドレス:</label>
            <input
              type="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              className={errors.email ? 'error' : ''}
            />
            {errors.email && (
              <span style={{ color: 'red', fontSize: '0.8em' }}>
                {errors.email}
              </span>
            )}
          </div>
          
          <div>
            <label>パスワード:</label>
            <input
              type="password"
              name="password"
              value={formData.password}
              onChange={handleChange}
              className={errors.password ? 'error' : ''}
            />
            {errors.password && (
              <span style={{ color: 'red', fontSize: '0.8em' }}>
                {errors.password}
              </span>
            )}
          </div>
          
          <div>
            <label>パスワード確認:</label>
            <input
              type="password"
              name="confirmPassword"
              value={formData.confirmPassword}
              onChange={handleChange}
              className={errors.confirmPassword ? 'error' : ''}
            />
            {errors.confirmPassword && (
              <span style={{ color: 'red', fontSize: '0.8em' }}>
                {errors.confirmPassword}
              </span>
            )}
          </div>
          
          <button type="submit">登録</button>
        </form>
      )}
    </div>
  );
}
```

### 6-4. 動的なリスト操作

#### 6-4-1. リストへの追加・削除・更新

実際のアプリケーションでは、リストの要素を動的に操作する必要があります。

```jsx
import { useState } from 'react';

function TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Reactを学ぶ', completed: false },
    { id: 2, text: 'プロジェクトを作る', completed: false }
  ]);
  const [newTodo, setNewTodo] = useState('');

  // 新しいTODOを追加
  const addTodo = (e) => {
    e.preventDefault();
    if (newTodo.trim()) {
      const newId = Math.max(...todos.map(t => t.id), 0) + 1;
      setTodos(prev => [...prev, {
        id: newId,
        text: newTodo.trim(),
        completed: false
      }]);
      setNewTodo('');
    }
  };

  // TODOを削除
  const deleteTodo = (id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  // TODOの完了状態を切り替え
  const toggleTodo = (id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  return (
    <div>
      <h2>TODOアプリ</h2>
      
      {/* 新しいTODOの入力フォーム */}
      <form onSubmit={addTodo}>
        <input
          type="text"
          value={newTodo}
          onChange={(e) => setNewTodo(e.target.value)}
          placeholder="新しいTODOを入力"
        />
        <button type="submit">追加</button>
      </form>

      {/* TODOリスト */}
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{
              textDecoration: todo.completed ? 'line-through' : 'none'
            }}>
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>削除</button>
          </li>
        ))}
      </ul>

      {/* 統計情報 */}
      <div>
        <p>総数: {todos.length}</p>
        <p>完了: {todos.filter(t => t.completed).length}</p>
        <p>未完了: {todos.filter(t => !t.completed).length}</p>
      </div>
    </div>
  );
}
```

#### 6-4-2. リストのフィルタリングとソート

```jsx
import { useState, useMemo } from 'react';

function ProductList() {
  const [products, setProducts] = useState([
    { id: 1, name: 'ノートPC', price: 80000, category: 'PC' },
    { id: 2, name: 'マウス', price: 3000, category: 'アクセサリ' },
    { id: 3, name: 'キーボード', price: 5000, category: 'アクセサリ' },
    { id: 4, name: 'モニター', price: 25000, category: 'PC' }
  ]);
  
  const [filter, setFilter] = useState('all');
  const [sortBy, setSortBy] = useState('name');

  // フィルタリングとソートを適用した商品リスト
  const filteredAndSortedProducts = useMemo(() => {
    let result = [...products];

    // フィルタリング
    if (filter !== 'all') {
      result = result.filter(product => product.category === filter);
    }

    // ソート
    result.sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      } else if (sortBy === 'price') {
        return a.price - b.price;
      }
      return 0;
    });

    return result;
  }, [products, filter, sortBy]);

  return (
    <div>
      <h2>商品一覧</h2>
      
      {/* フィルター */}
      <div>
        <label>カテゴリ:</label>
        <select value={filter} onChange={(e) => setFilter(e.target.value)}>
          <option value="all">すべて</option>
          <option value="PC">PC</option>
          <option value="アクセサリ">アクセサリ</option>
        </select>
      </div>

      {/* ソート */}
      <div>
        <label>並び順:</label>
        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="name">名前順</option>
          <option value="price">価格順</option>
        </select>
      </div>

      {/* 商品リスト */}
      <ul>
        {filteredAndSortedProducts.map(product => (
          <li key={product.id}>
            <h3>{product.name}</h3>
            <p>価格: ¥{product.price.toLocaleString()}</p>
            <p>カテゴリ: {product.category}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 6-5. 高度なフォーム機能

#### 6-5-1. ファイルアップロード

```jsx
import { useState } from 'react';

function FileUploadForm() {
  const [selectedFile, setSelectedFile] = useState(null);
  const [preview, setPreview] = useState(null);

  const handleFileChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      setSelectedFile(file);
      
      // 画像プレビューの作成
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => setPreview(e.target.result);
        reader.readAsDataURL(file);
      }
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (selectedFile) {
      console.log('アップロードするファイル:', selectedFile);
      // 実際のファイルアップロード処理
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>ファイルを選択:</label>
        <input
          type="file"
          onChange={handleFileChange}
          accept="image/*"
        />
      </div>
      
      {preview && (
        <div>
          <h4>プレビュー:</h4>
          <img 
            src={preview} 
            alt="プレビュー" 
            style={{ maxWidth: '200px', maxHeight: '200px' }}
          />
        </div>
      )}
      
      {selectedFile && (
        <div>
          <p>選択されたファイル: {selectedFile.name}</p>
          <p>サイズ: {(selectedFile.size / 1024).toFixed(2)} KB</p>
        </div>
      )}
      
      <button type="submit" disabled={!selectedFile}>
        アップロード
      </button>
    </form>
  );
}
```

#### 6-5-2. 複数選択フォーム

```jsx
import { useState } from 'react';

function MultiSelectForm() {
  const [selectedSkills, setSelectedSkills] = useState([]);
  const [selectedDays, setSelectedDays] = useState([]);

  const skills = ['JavaScript', 'React', 'Node.js', 'Python', 'Java', 'C++'];
  const days = ['月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日', '日曜日'];

  const handleSkillChange = (skill) => {
    setSelectedSkills(prev => 
      prev.includes(skill)
        ? prev.filter(s => s !== skill)
        : [...prev, skill]
    );
  };

  const handleDayChange = (day) => {
    setSelectedDays(prev => 
      prev.includes(day)
        ? prev.filter(d => d !== day)
        : [...prev, day]
    );
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('選択されたスキル:', selectedSkills);
    console.log('選択された曜日:', selectedDays);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <h3>得意なスキル（複数選択可）</h3>
        {skills.map(skill => (
          <label key={skill}>
            <input
              type="checkbox"
              checked={selectedSkills.includes(skill)}
              onChange={() => handleSkillChange(skill)}
            />
            {skill}
          </label>
        ))}
      </div>

      <div>
        <h3>勤務可能な曜日（複数選択可）</h3>
        {days.map(day => (
          <label key={day}>
            <input
              type="checkbox"
              checked={selectedDays.includes(day)}
              onChange={() => handleDayChange(day)}
            />
            {day}
          </label>
        ))}
      </div>

      <button type="submit">送信</button>
    </form>
  );
}
```

### 6-6. フォームのカスタムフック

#### 6-6-1. 再利用可能なフォームフック

```jsx
import { useState, useCallback } from 'react';

// フォーム管理のカスタムフック
function useForm(initialValues = {}) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  const handleChange = useCallback((e) => {
    const { name, value, type, checked } = e.target;
    setValues(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // エラーをクリア
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  }, [errors]);

  const setValue = useCallback((name, value) => {
    setValues(prev => ({
      ...prev,
      [name]: value
    }));
  }, []);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
  }, [initialValues]);

  return {
    values,
    errors,
    handleChange,
    setValue,
    setErrors,
    reset
  };
}

// 使用例
function UserRegistrationForm() {
  const { values, errors, handleChange, setErrors, reset } = useForm({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
  });

  const validateForm = () => {
    const newErrors = {};

    if (!values.name) newErrors.name = '名前は必須です';
    if (!values.email) newErrors.email = 'メールアドレスは必須です';
    if (values.password !== values.confirmPassword) {
      newErrors.confirmPassword = 'パスワードが一致しません';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validateForm()) {
      console.log('送信データ:', values);
      reset();
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>名前:</label>
        <input
          name="name"
          value={values.name}
          onChange={handleChange}
        />
        {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
      </div>

      <div>
        <label>メールアドレス:</label>
        <input
          name="email"
          type="email"
          value={values.email}
          onChange={handleChange}
        />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>

      <div>
        <label>パスワード:</label>
        <input
          name="password"
          type="password"
          value={values.password}
          onChange={handleChange}
        />
      </div>

      <div>
        <label>パスワード確認:</label>
        <input
          name="confirmPassword"
          type="password"
          value={values.confirmPassword}
          onChange={handleChange}
        />
        {errors.confirmPassword && (
          <span style={{ color: 'red' }}>{errors.confirmPassword}</span>
        )}
      </div>

      <button type="submit">登録</button>
      <button type="button" onClick={reset}>リセット</button>
    </form>
  );
}
```

### 6-7. 実践的な応用例

#### 6-7-1. 検索機能付きリスト

```jsx
import { useState, useMemo } from 'react';

function SearchableList() {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');

  const items = [
    { id: 1, name: 'React入門', category: 'プログラミング', author: '田中太郎' },
    { id: 2, name: 'JavaScript基礎', category: 'プログラミング', author: '佐藤花子' },
    { id: 3, name: 'デザインの原則', category: 'デザイン', author: '鈴木一郎' },
    { id: 4, name: 'UI/UX設計', category: 'デザイン', author: '高橋美咲' },
    { id: 5, name: 'プロジェクト管理', category: 'マネジメント', author: '渡辺健太' }
  ];

  const categories = ['all', ...new Set(items.map(item => item.category))];

  const filteredItems = useMemo(() => {
    return items.filter(item => {
      const matchesSearch = item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                           item.author.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesCategory = selectedCategory === 'all' || item.category === selectedCategory;
      
      return matchesSearch && matchesCategory;
    });
  }, [searchTerm, selectedCategory]);

  return (
    <div>
      <h2>検索可能なリスト</h2>
      
      {/* 検索フィールド */}
      <div>
        <input
          type="text"
          placeholder="検索..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>

      {/* カテゴリフィルター */}
      <div>
        <select 
          value={selectedCategory} 
          onChange={(e) => setSelectedCategory(e.target.value)}
        >
          {categories.map(category => (
            <option key={category} value={category}>
              {category === 'all' ? 'すべて' : category}
            </option>
          ))}
        </select>
      </div>

      {/* 結果表示 */}
      <div>
        <p>検索結果: {filteredItems.length}件</p>
        <ul>
          {filteredItems.map(item => (
            <li key={item.id}>
              <h3>{item.name}</h3>
              <p>著者: {item.author}</p>
              <p>カテゴリ: {item.category}</p>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

#### 6-7-2. ドラッグ&ドロップリスト

```jsx
import { useState } from 'react';

function DraggableList() {
  const [items, setItems] = useState([
    { id: 1, text: 'アイテム1' },
    { id: 2, text: 'アイテム2' },
    { id: 3, text: 'アイテム3' },
    { id: 4, text: 'アイテム4' }
  ]);

  const [draggedItem, setDraggedItem] = useState(null);

  const handleDragStart = (e, index) => {
    setDraggedItem(index);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
  };

  const handleDrop = (e, dropIndex) => {
    e.preventDefault();
    
    if (draggedItem !== null && draggedItem !== dropIndex) {
      const newItems = [...items];
      const [draggedItemData] = newItems.splice(draggedItem, 1);
      newItems.splice(dropIndex, 0, draggedItemData);
      setItems(newItems);
    }
    
    setDraggedItem(null);
  };

  return (
    <div>
      <h2>ドラッグ&ドロップリスト</h2>
      <ul>
        {items.map((item, index) => (
          <li
            key={item.id}
            draggable
            onDragStart={(e) => handleDragStart(e, index)}
            onDragOver={handleDragOver}
            onDrop={(e) => handleDrop(e, index)}
            style={{
              padding: '10px',
              margin: '5px 0',
              backgroundColor: draggedItem === index ? '#e0e0e0' : '#f5f5f5',
              cursor: 'grab',
              border: '1px solid #ddd'
            }}
          >
            {item.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 6-8. パフォーマンス最適化

#### 6-8-1. 仮想化リスト（Virtualization）

大量のデータを表示する場合、仮想化を使用してパフォーマンスを向上させることができます。

```jsx
import { useState, useMemo } from 'react';

function VirtualizedList() {
  const [scrollTop, setScrollTop] = useState(0);
  const itemHeight = 50;
  const containerHeight = 400;
  const visibleItemsCount = Math.ceil(containerHeight / itemHeight);

  // 大量のデータを生成
  const items = useMemo(() => {
    return Array.from({ length: 10000 }, (_, index) => ({
      id: index,
      text: `アイテム ${index + 1}`
    }));
  }, []);

  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleItemsCount + 1, items.length);

  const visibleItems = items.slice(startIndex, endIndex);

  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  return (
    <div>
      <h2>仮想化リスト（10,000アイテム）</h2>
      <div
        style={{
          height: containerHeight,
          overflow: 'auto',
          border: '1px solid #ccc'
        }}
        onScroll={handleScroll}
      >
        <div style={{ height: items.length * itemHeight }}>
          <div
            style={{
              position: 'relative',
              top: startIndex * itemHeight
            }}
          >
            {visibleItems.map(item => (
              <div
                key={item.id}
                style={{
                  height: itemHeight,
                  padding: '10px',
                  borderBottom: '1px solid #eee',
                  backgroundColor: '#f9f9f9'
                }}
              >
                {item.text}
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 6-9. まとめ

この章では、Reactにおけるリストとフォームの扱いについて詳しく学びました：

**重要なポイント：**
1. **配列のレンダリング**: `map`メソッドを使用して配列をJSXに変換
2. **key属性**: リストの各要素に一意のkeyを指定してReactの最適化を支援
3. **制御されたコンポーネント**: フォームの値をuseStateで管理
4. **動的なリスト操作**: 追加・削除・更新・フィルタリング・ソート
5. **フォームバリデーション**: 入力値の検証とエラーハンドリング
6. **カスタムフック**: 再利用可能なフォームロジックの作成

**ベストプラクティス：**
- key属性には一意のIDを使用する（インデックスは避ける）
- フォームの状態は適切に管理する
- バリデーションはユーザーフレンドリーに行う
- 大量のデータには仮想化を検討する
- カスタムフックでロジックを再利用する

これらの知識を活用して、ユーザーフレンドリーで効率的なReactアプリケーションを構築しましょう。