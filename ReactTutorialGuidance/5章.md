## 第5章：副作用とライフサイクル

### 5-1. 副作用（Side Effects）とは何か？

#### 5-1-1. 副作用の基本概念

**副作用（Side Effects）**とは、Reactコンポーネントのレンダリング以外で発生する処理のことです。

**純粋な関数 vs 副作用のある関数**

```jsx
// 純粋な関数（副作用なし）
function add(a, b) {
  return a + b;
}

// 副作用のある関数
function updateTitle(newTitle) {
  document.title = newTitle; // DOMを直接操作
}
```

**Reactにおける副作用の例：**
- APIからのデータ取得
- DOMの直接操作
- タイマーの設定・解除
- イベントリスナーの登録・解除
- ローカルストレージへの保存
- ログ出力

#### 5-1-2. なぜ副作用を特別に扱うのか？

Reactの関数コンポーネントは**純粋関数**として設計されています。つまり：
- 同じ入力（props）に対して常に同じ出力（JSX）を返す
- 外部の状態を変更しない
- 予測可能でテストしやすい

しかし、実際のアプリケーションでは副作用が必要不可欠です。そのため、Reactは`useEffect`フックを提供して、副作用を適切に管理できるようにしています。

### 5-2. `useEffect`の基本的な使い方

#### 5-2-1. `useEffect`の構文

```jsx
useEffect(() => {
  // 副作用の処理をここに書く
  return () => {
    // クリーンアップ処理（オプション）
  };
}, [依存配列]);
```

**パラメータの説明：**
1. **第一引数（関数）**: 実行したい副作用の処理
2. **第二引数（配列）**: 依存配列（いつ実行するかを決める）

#### 5-2-2. 基本的な例：タイマーコンポーネント

```jsx
import { useEffect, useState } from 'react';

function Timer() {
  const [time, setTime] = useState(0);

  useEffect(() => {
    // 1秒ごとにtimeを更新するタイマーを設定
    const intervalId = setInterval(() => {
      setTime(prevTime => prevTime + 1);
    }, 1000);

    // クリーンアップ関数：コンポーネントがアンマウントされる時に実行
    return () => {
      clearInterval(intervalId);
    };
  }, []); // 空の依存配列 = マウント時のみ実行

  return (
    <div>
      <h3>タイマー</h3>
      <p>経過時間: {time}秒</p>
    </div>
  );
}
```

**この例のポイント：**
- `setInterval`でタイマーを開始
- クリーンアップ関数で`clearInterval`を実行してメモリリークを防止
- 空の依存配列`[]`により、マウント時のみ実行

### 5-3. ライフサイクルと実行タイミング

#### 5-3-1. コンポーネントのライフサイクル

Reactコンポーネントには以下のライフサイクルがあります：

1. **マウント（Mount）**: コンポーネントが初めて画面に表示される
2. **更新（Update）**: propsやstateが変更されて再レンダリングされる
3. **アンマウント（Unmount）**: コンポーネントが画面から消える

#### 5-3-2. `useEffect`の実行タイミング

| 実行タイミング | 依存配列 | 使用例 |
|---------------|----------|--------|
| マウント時のみ | `[]` | 初期データ取得、タイマー開始 |
| 毎回のレンダリング後 | 省略 | DOMの直接操作（非推奨） |
| 特定の値が変更された時 | `[value]` | 値の変更に応じた処理 |
| 複数の値が変更された時 | `[value1, value2]` | 複数条件での処理 |

#### 5-3-3. 実践的な例：ユーザー情報の取得

```jsx
import { useEffect, useState } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // userIdが変更された時に実行
    const fetchUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
          throw new Error('ユーザーが見つかりません');
        }
        
        const userData = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]); // userIdが変更された時に再実行

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;
  if (!user) return <div>ユーザーが見つかりません</div>;

  return (
    <div>
      <h2>{user.name}</h2>
      <p>Email: {user.email}</p>
      <p>役職: {user.role}</p>
    </div>
  );
}
```

### 5-4. 依存配列の詳細理解

#### 5-4-1. 依存配列の基本ルール

```jsx
// ❌ 悪い例：依存配列を省略
useEffect(() => {
  console.log(count);
}); // 毎回実行される

// ✅ 良い例：依存配列を明示
useEffect(() => {
  console.log(count);
}, [count]); // countが変更された時のみ実行
```

#### 5-4-2. 依存配列のパターン

```jsx
// 1. マウント時のみ実行
useEffect(() => {
  console.log('コンポーネントがマウントされました');
}, []);

// 2. 特定の値が変更された時に実行
useEffect(() => {
  console.log(`ユーザー名が ${username} に変更されました`);
}, [username]);

// 3. 複数の値が変更された時に実行
useEffect(() => {
  console.log(`ユーザー ${username} の年齢が ${age} に変更されました`);
}, [username, age]);

// 4. 毎回実行（非推奨）
useEffect(() => {
  console.log('毎回実行されます');
}); // 依存配列を省略
```

#### 5-4-3. よくある間違いと解決方法

**問題1: 依存配列の不足**

```jsx
// ❌ 問題のあるコード
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    document.title = `カウント: ${count}`;
  }, []); // countが依存配列に含まれていない
  
  return (
    <button onClick={() => setCount(count + 1)}>
      カウント: {count}
    </button>
  );
}
```

**解決方法：**

```jsx
// ✅ 正しいコード
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    document.title = `カウント: ${count}`;
  }, [count]); // countを依存配列に追加
  
  return (
    <button onClick={() => setCount(count + 1)}>
      カウント: {count}
    </button>
  );
}
```

**問題2: 無限ループ**

```jsx
// ❌ 無限ループが発生するコード
function BadExample() {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    setData([...data, '新しいアイテム']); // dataが変更される
  }, [data]); // dataが変更されると再実行 → 無限ループ
}
```

**解決方法：**

```jsx
// ✅ 正しいコード
function GoodExample() {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    setData(prevData => [...prevData, '新しいアイテム']); // 関数形式で更新
  }, []); // マウント時のみ実行
}
```

### 5-5. クリーンアップ処理

#### 5-5-1. クリーンアップとは？

クリーンアップ処理は、副作用で設定したリソースを適切に解放するための処理です。

**クリーンアップが必要な例：**
- タイマー（`setInterval`, `setTimeout`）
- イベントリスナー
- WebSocket接続
- サブスクリプション

#### 5-5-2. クリーンアップの基本パターン

```jsx
useEffect(() => {
  // リソースの設定
  const resource = setupResource();
  
  // クリーンアップ関数を返す
  return () => {
    cleanupResource(resource);
  };
}, []);
```

#### 5-5-3. 実践的なクリーンアップ例

**例1: タイマーのクリーンアップ**

```jsx
function TimerWithCleanup() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    let intervalId = null;
    
    if (isRunning) {
      intervalId = setInterval(() => {
        setTime(prev => prev + 1);
      }, 1000);
    }

    // クリーンアップ関数
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isRunning]); // isRunningが変更された時に実行

  return (
    <div>
      <p>時間: {time}秒</p>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? '停止' : '開始'}
      </button>
      <button onClick={() => setTime(0)}>リセット</button>
    </div>
  );
}
```

**例2: イベントリスナーのクリーンアップ**

```jsx
function WindowResizeTracker() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    // イベントリスナーを登録
    window.addEventListener('resize', handleResize);

    // クリーンアップ関数
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // マウント時のみ実行

  return (
    <div>
      <h3>ウィンドウサイズ</h3>
      <p>幅: {windowSize.width}px</p>
      <p>高さ: {windowSize.height}px</p>
    </div>
  );
}
```

**例3: APIサブスクリプションのクリーンアップ**

```jsx
function DataSubscription({ userId }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    let isSubscribed = true; // アンマウントフラグ

    const fetchData = async () => {
      try {
        const response = await fetch(`/api/data/${userId}`);
        const result = await response.json();
        
        // コンポーネントがまだマウントされている場合のみ更新
        if (isSubscribed) {
          setData(result);
        }
      } catch (error) {
        if (isSubscribed) {
          console.error('データ取得エラー:', error);
        }
      }
    };

    fetchData();

    // クリーンアップ関数
    return () => {
      isSubscribed = false; // アンマウントフラグを設定
    };
  }, [userId]);

  return (
    <div>
      {data ? (
        <div>データ: {JSON.stringify(data)}</div>
      ) : (
        <div>読み込み中...</div>
      )}
    </div>
  );
}
```

### 5-6. 複数の`useEffect`の管理

#### 5-6-1. 複数の副作用を分離する

関連する副作用は別々の`useEffect`に分けることで、コードの可読性と保守性が向上します。

```jsx
function UserDashboard({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [isOnline, setIsOnline] = useState(false);

  // ユーザー情報の取得
  useEffect(() => {
    const fetchUser = async () => {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      setUser(userData);
    };
    fetchUser();
  }, [userId]);

  // ユーザーの投稿を取得
  useEffect(() => {
    const fetchPosts = async () => {
      const response = await fetch(`/api/users/${userId}/posts`);
      const postsData = await response.json();
      setPosts(postsData);
    };
    fetchPosts();
  }, [userId]);

  // オンライン状態の監視
  useEffect(() => {
    const checkOnlineStatus = () => {
      setIsOnline(navigator.onLine);
    };

    window.addEventListener('online', checkOnlineStatus);
    window.addEventListener('offline', checkOnlineStatus);
    checkOnlineStatus(); // 初期状態をチェック

    return () => {
      window.removeEventListener('online', checkOnlineStatus);
      window.removeEventListener('offline', checkOnlineStatus);
    };
  }, []); // userIdに依存しない

  return (
    <div>
      <h2>{user?.name}のダッシュボード</h2>
      <p>オンライン状態: {isOnline ? 'オンライン' : 'オフライン'}</p>
      <h3>投稿一覧</h3>
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 5-7. カスタムフックでの副作用管理

#### 5-7-1. カスタムフックとは？

カスタムフックは、複数のコンポーネントで再利用可能なロジックをまとめた関数です。

#### 5-7-2. 副作用を含むカスタムフックの例

**データ取得のカスタムフック**

```jsx
import { useState, useEffect } from 'react';

// データ取得のカスタムフック
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isSubscribed = true;

    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (isSubscribed) {
          setData(result);
        }
      } catch (err) {
        if (isSubscribed) {
          setError(err.message);
        }
      } finally {
        if (isSubscribed) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      isSubscribed = false;
    };
  }, [url]);

  return { data, loading, error };
}

// 使用例
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**ローカルストレージのカスタムフック**

```jsx
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  // 初期値をローカルストレージから取得
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`ローカルストレージから ${key} を取得できませんでした:`, error);
      return initialValue;
    }
  });

  // 値が変更されたらローカルストレージに保存
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`ローカルストレージに ${key} を保存できませんでした:`, error);
    }
  };

  return [storedValue, setValue];
}

// 使用例
function ThemeToggle() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  useEffect(() => {
    document.body.className = theme;
  }, [theme]);

  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      テーマを切り替え: {theme}
    </button>
  );
}
```

### 5-8. 実践的な応用例

#### 5-8-1. フォームの自動保存

```jsx
import { useState, useEffect } from 'react';

function AutoSaveForm() {
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    author: ''
  });
  const [saved, setSaved] = useState(true);

  // フォームデータが変更されたら自動保存
  useEffect(() => {
    if (!saved) {
      const timeoutId = setTimeout(() => {
        // 実際のAPI呼び出しをシミュレート
        console.log('自動保存:', formData);
        setSaved(true);
      }, 1000); // 1秒後に保存

      return () => clearTimeout(timeoutId);
    }
  }, [formData, saved]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    setSaved(false);
  };

  return (
    <form>
      <div>
        <label>タイトル:</label>
        <input
          name="title"
          value={formData.title}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>内容:</label>
        <textarea
          name="content"
          value={formData.content}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>著者:</label>
        <input
          name="author"
          value={formData.author}
          onChange={handleChange}
        />
      </div>
      <p>保存状態: {saved ? '保存済み' : '保存中...'}</p>
    </form>
  );
}
```

#### 5-8-2. 無限スクロール

```jsx
import { useState, useEffect, useRef } from 'react';

function InfiniteScroll() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const observerRef = useRef();

  // データ取得
  useEffect(() => {
    const fetchItems = async () => {
      setLoading(true);
      try {
        // 実際のAPI呼び出しをシミュレート
        const response = await fetch(`/api/items?page=${page}`);
        const newItems = await response.json();
        
        setItems(prev => [...prev, ...newItems]);
        setHasMore(newItems.length > 0);
      } catch (error) {
        console.error('データ取得エラー:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchItems();
  }, [page]);

  // 無限スクロールの監視
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          setPage(prev => prev + 1);
        }
      },
      { threshold: 0.1 }
    );

    if (observerRef.current) {
      observer.observe(observerRef.current);
    }

    return () => observer.disconnect();
  }, [hasMore, loading]);

  return (
    <div>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item.name}</li>
        ))}
      </ul>
      {loading && <div>読み込み中...</div>}
      {hasMore && <div ref={observerRef}>監視要素</div>}
    </div>
  );
}
```

### 5-9. パフォーマンス最適化

#### 5-9-1. `useCallback`と`useMemo`との組み合わせ

```jsx
import { useState, useEffect, useCallback, useMemo } from 'react';

function OptimizedComponent({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);

  // メモ化されたコールバック関数
  const fetchUser = useCallback(async () => {
    const response = await fetch(`/api/users/${userId}`);
    const userData = await response.json();
    setUser(userData);
  }, [userId]);

  // メモ化された計算結果
  const userStats = useMemo(() => {
    if (!user || !posts) return null;
    
    return {
      totalPosts: posts.length,
      averageLikes: posts.reduce((sum, post) => sum + post.likes, 0) / posts.length
    };
  }, [user, posts]);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  return (
    <div>
      {userStats && (
        <div>
          <p>総投稿数: {userStats.totalPosts}</p>
          <p>平均いいね数: {userStats.averageLikes}</p>
        </div>
      )}
    </div>
  );
}
```

### 5-10. よくある問題と解決方法

#### 5-10-1. ESLintの警告への対応

```jsx
// ESLintの警告が出る場合
useEffect(() => {
  console.log(someValue);
}, []); // ESLint: someValueが依存配列に含まれていない

// 解決方法1: 依存配列に追加
useEffect(() => {
  console.log(someValue);
}, [someValue]);

// 解決方法2: ESLintルールを無効化（非推奨）
useEffect(() => {
  console.log(someValue);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);

// 解決方法3: useRefを使用
const someValueRef = useRef(someValue);
useEffect(() => {
  someValueRef.current = someValue;
}, [someValue]);

useEffect(() => {
  console.log(someValueRef.current);
}, []);
```

#### 5-10-2. 非同期処理の適切な処理

```jsx
// ❌ 問題のあるコード
useEffect(() => {
  const fetchData = async () => {
    const response = await fetch('/api/data');
    const data = await response.json();
    setData(data); // コンポーネントがアンマウントされている可能性
  };
  fetchData();
}, []);

// ✅ 正しいコード
useEffect(() => {
  let isSubscribed = true;

  const fetchData = async () => {
    try {
      const response = await fetch('/api/data');
      const data = await response.json();
      
      if (isSubscribed) {
        setData(data);
      }
    } catch (error) {
      if (isSubscribed) {
        setError(error.message);
      }
    }
  };

  fetchData();

  return () => {
    isSubscribed = false;
  };
}, []);
```

### 5-11. まとめ

この章では、Reactにおける副作用の管理について詳しく学びました：

**重要なポイント：**
1. **副作用とは**: レンダリング以外の処理（API呼び出し、DOM操作など）
2. **useEffectの基本**: 副作用を適切に管理するためのフック
3. **依存配列**: いつ副作用を実行するかを制御
4. **クリーンアップ**: リソースの適切な解放
5. **カスタムフック**: 再利用可能な副作用ロジックの作成

**ベストプラクティス：**
- 関連する副作用は分離する
- 依存配列は適切に設定する
- クリーンアップ処理を忘れない
- 非同期処理ではアンマウントフラグを使用する
- カスタムフックでロジックを再利用する

これらの知識を活用して、効率的で保守性の高いReactアプリケーションを構築しましょう。
