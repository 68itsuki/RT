## 第9章：コンポーネントの再利用と設計

### 9-1. コンポーネントの分割と粒度

#### なぜコンポーネントを分割するのか？

**1つのコンポーネントが大きすぎると読みにくくなる**ため、小さな単位に分けるのが基本です。

**分割のメリット：**
- **可読性の向上**：コードが読みやすくなる
- **再利用性**：同じコンポーネントを他の場所でも使える
- **保守性**：バグ修正や機能追加が容易になる
- **テストしやすさ**：小さなコンポーネントはテストしやすい
- **チーム開発**：複数人で同時に開発しやすくなる

#### 分割の基準

```
✔️ OK:
App → Header / UserList / Footer / Sidebar

❌ NG:
Appコンポーネントに全部まとめる
```

**分割の判断基準：**
1. **単一責任の原則**：1つのコンポーネントは1つの役割のみ
2. **再利用可能性**：他の場所でも使えそうか
3. **複雑度**：100行を超える場合は分割を検討
4. **状態の独立性**：独立した状態管理が必要か

#### 実践例：Todoアプリの分割

```jsx
// ❌ 悪い例：全てを1つのコンポーネントに
function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  
  return (
    <div>
      <h1>Todoアプリ</h1>
      <form onSubmit={handleSubmit}>
        <input value={input} onChange={(e) => setInput(e.target.value)} />
        <button type="submit">追加</button>
      </form>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input 
              type="checkbox" 
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>削除</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

```jsx
// ✔️ 良い例：適切に分割
function TodoApp() {
  const [todos, setTodos] = useState([]);
  
  return (
    <div>
      <TodoHeader />
      <TodoForm onAdd={addTodo} />
      <TodoList todos={todos} onToggle={toggleTodo} onDelete={deleteTodo} />
    </div>
  );
}

function TodoHeader() {
  return <h1>Todoアプリ</h1>;
}

function TodoForm({ onAdd }) {
  const [input, setInput] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (input.trim()) {
      onAdd(input);
      setInput('');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input 
        value={input} 
        onChange={(e) => setInput(e.target.value)}
        placeholder="新しいタスクを入力"
      />
      <button type="submit">追加</button>
    </form>
  );
}

function TodoList({ todos, onToggle, onDelete }) {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem 
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
        />
      ))}
    </ul>
  );
}

function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <li>
      <input 
        type="checkbox" 
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span style={{ 
        textDecoration: todo.completed ? 'line-through' : 'none' 
      }}>
        {todo.text}
      </span>
      <button onClick={() => onDelete(todo.id)}>削除</button>
    </li>
  );
}
```

### 9-2. コンポーネントの設計パターン

#### Presentational Component（プレゼンテーショナルコンポーネント）

**特徴：**
- UIの表示だけを担当
- ロジックは持たない
- propsからデータを受け取る
- 再利用しやすい
- テストしやすい

**命名規則：**
- 通常の関数名（例：`UserCard`）
- または`View`サフィックス（例：`UserCardView`）

```jsx
// Presentational Component
function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <p>年齢: {user.age}歳</p>
      <div className="actions">
        <button onClick={() => onEdit(user.id)}>編集</button>
        <button onClick={() => onDelete(user.id)}>削除</button>
      </div>
    </div>
  );
}

// 使用例
<UserCard 
  user={{ id: 1, name: "田中太郎", email: "tanaka@example.com", age: 25 }}
  onEdit={(id) => console.log('編集:', id)}
  onDelete={(id) => console.log('削除:', id)}
/>
```

#### Container Component（コンテナコンポーネント）

**特徴：**
- 状態管理や処理を担当
- 見た目の部分は子に任せる
- API呼び出しやデータ処理を行う
- ビジネスロジックを含む

**命名規則：**
- `Container`サフィックス（例：`UserListContainer`）
- または機能名（例：`UserList`）

```jsx
// Container Component
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/users');
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError('ユーザー情報の取得に失敗しました');
    } finally {
      setLoading(false);
    }
  };

  const handleEdit = (userId) => {
    // 編集ロジック
    console.log('編集:', userId);
  };

  const handleDelete = async (userId) => {
    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      setUsers(users.filter(user => user.id !== userId));
    } catch (err) {
      setError('削除に失敗しました');
    }
  };

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <div className="user-list">
      <h2>ユーザー一覧</h2>
      {users.map(user => (
        <UserCard 
          key={user.id}
          user={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

#### パターンの組み合わせ例

```jsx
// より実践的な例：商品一覧
function ProductListContainer() {
  const [products, setProducts] = useState([]);
  const [filters, setFilters] = useState({ category: 'all', price: 'all' });
  const [sortBy, setSortBy] = useState('name');

  // フィルタリングとソートのロジック
  const filteredAndSortedProducts = useMemo(() => {
    let result = products;
    
    // フィルタリング
    if (filters.category !== 'all') {
      result = result.filter(p => p.category === filters.category);
    }
    if (filters.price !== 'all') {
      result = result.filter(p => p.price <= parseInt(filters.price));
    }
    
    // ソート
    result.sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'price') return a.price - b.price;
      return 0;
    });
    
    return result;
  }, [products, filters, sortBy]);

  return (
    <div>
      <ProductFilters 
        filters={filters}
        onFilterChange={setFilters}
        sortBy={sortBy}
        onSortChange={setSortBy}
      />
      <ProductGrid products={filteredAndSortedProducts} />
    </div>
  );
}

// Presentational Components
function ProductFilters({ filters, onFilterChange, sortBy, onSortChange }) {
  return (
    <div className="filters">
      <select 
        value={filters.category} 
        onChange={(e) => onFilterChange({...filters, category: e.target.value})}
      >
        <option value="all">全カテゴリ</option>
        <option value="electronics">電子機器</option>
        <option value="clothing">衣類</option>
      </select>
      
      <select 
        value={sortBy} 
        onChange={(e) => onSortChange(e.target.value)}
      >
        <option value="name">名前順</option>
        <option value="price">価格順</option>
      </select>
    </div>
  );
}

function ProductGrid({ products }) {
  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

function ProductCard({ product }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>¥{product.price.toLocaleString()}</p>
      <button>カートに追加</button>
    </div>
  );
}
```

### 9-3. コンポーネントの再利用パターン

#### 1. 高階コンポーネント（HOC: Higher-Order Component）

**概念：**
- コンポーネントを受け取り、新しいコンポーネントを返す関数
- 共通の機能を複数のコンポーネントに提供

```jsx
// ローディング状態を提供するHOC
function withLoading(WrappedComponent) {
  return function WithLoadingComponent({ loading, ...props }) {
    if (loading) {
      return <div>読み込み中...</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

// 使用例
const UserListWithLoading = withLoading(UserList);
const ProductListWithLoading = withLoading(ProductList);

// 使用
<UserListWithLoading loading={isLoading} users={users} />
```

#### 2. Render Props パターン

**概念：**
- コンポーネントが関数をpropsとして受け取り、その関数を呼び出してレンダリング

```jsx
// データフェッチングを提供するコンポーネント
function DataFetcher({ url, children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [url]);

  return children({ data, loading, error });
}

// 使用例
<DataFetcher url="/api/users">
  {({ data, loading, error }) => {
    if (loading) return <div>読み込み中...</div>;
    if (error) return <div>エラー: {error}</div>;
    return <UserList users={data} />;
  }}
</DataFetcher>
```

#### 3. カスタムフック

**概念：**
- 共通のロジックをフックとして抽出
- 最も現代的な再利用パターン

```jsx
// データフェッチングのカスタムフック
function useDataFetching(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// 使用例
function UserList() {
  const { data: users, loading, error } = useDataFetching('/api/users');

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

### 9-4. PropTypesによるpropsの型チェック

#### なぜPropTypesを使うのか？

**メリット：**
- 開発中のバグを早期発見
- コンポーネントの使用方法を明確化
- チーム開発での理解促進
- TypeScriptの代替として使用可能

#### 基本的な使用方法

```bash
npm install prop-types
```

```jsx
import PropTypes from 'prop-types';

function UserProfile({ user, onEdit, showEmail = true }) {
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      {showEmail && <p>{user.email}</p>}
      <button onClick={() => onEdit(user.id)}>編集</button>
    </div>
  );
}

// PropTypesの定義
UserProfile.propTypes = {
  user: PropTypes.shape({
    id: PropTypes.number.isRequired,
    name: PropTypes.string.isRequired,
    email: PropTypes.string.isRequired,
    age: PropTypes.number
  }).isRequired,
  onEdit: PropTypes.func.isRequired,
  showEmail: PropTypes.bool
};

// デフォルト値の設定
UserProfile.defaultProps = {
  showEmail: true
};
```

#### よく使うPropTypes

```jsx
function ExampleComponent({ 
  name, 
  age, 
  isActive, 
  items, 
  user, 
  onClick, 
  children 
}) {
  return <div>コンポーネント</div>;
}

ExampleComponent.propTypes = {
  // 基本型
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  isActive: PropTypes.bool,
  
  // 配列とオブジェクト
  items: PropTypes.arrayOf(PropTypes.string),
  user: PropTypes.shape({
    id: PropTypes.number.isRequired,
    name: PropTypes.string.isRequired,
    email: PropTypes.string
  }),
  
  // 関数
  onClick: PropTypes.func,
  
  // 子要素
  children: PropTypes.node,
  
  // 複数の型を許可
  value: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number
  ]),
  
  // 特定の値のみ許可
  status: PropTypes.oneOf(['pending', 'success', 'error']),
  
  // カスタムバリデーション
  score: function(props, propName, componentName) {
    if (props[propName] < 0 || props[propName] > 100) {
      return new Error(
        `${componentName}の${propName}は0から100の間である必要があります`
      );
    }
  }
};
```

#### 実践的な例

```jsx
function ProductCard({ product, onAddToCart, onViewDetails }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p className="price">¥{product.price.toLocaleString()}</p>
      <div className="actions">
        <button onClick={() => onAddToCart(product.id)}>
          カートに追加
        </button>
        <button onClick={() => onViewDetails(product.id)}>
          詳細を見る
        </button>
      </div>
    </div>
  );
}

ProductCard.propTypes = {
  product: PropTypes.shape({
    id: PropTypes.number.isRequired,
    name: PropTypes.string.isRequired,
    price: PropTypes.number.isRequired,
    image: PropTypes.string.isRequired,
    description: PropTypes.string,
    category: PropTypes.oneOf(['electronics', 'clothing', 'books']),
    inStock: PropTypes.bool
  }).isRequired,
  onAddToCart: PropTypes.func.isRequired,
  onViewDetails: PropTypes.func.isRequired
};

// 使用例
<ProductCard 
  product={{
    id: 1,
    name: "スマートフォン",
    price: 50000,
    image: "/images/phone.jpg",
    category: "electronics",
    inStock: true
  }}
  onAddToCart={(id) => console.log('カートに追加:', id)}
  onViewDetails={(id) => console.log('詳細表示:', id)}
/>
```

### 9-5. コンポーネント設計のベストプラクティス

#### 1. 命名規則

```jsx
// ✅ 良い例
function UserProfile() { }
function ProductCard() { }
function TodoList() { }

// ❌ 悪い例
function user() { }
function Card() { }
function List() { }
```

#### 2. Propsの設計

```jsx
// ✅ 良い例：明確で具体的
function Button({ 
  children, 
  variant = 'primary', 
  size = 'medium',
  disabled = false,
  onClick 
}) {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

// ❌ 悪い例：曖昧で汎用的すぎる
function Button({ props }) {
  return <button {...props} />;
}
```

#### 3. 状態管理の設計

```jsx
// ✅ 良い例：状態を適切に分割
function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');
  const [sortBy, setSortBy] = useState('created');

  // フィルタリングとソートのロジック
  const filteredTodos = useMemo(() => {
    let result = todos;
    
    if (filter === 'active') {
      result = result.filter(todo => !todo.completed);
    } else if (filter === 'completed') {
      result = result.filter(todo => todo.completed);
    }
    
    if (sortBy === 'created') {
      result.sort((a, b) => b.createdAt - a.createdAt);
    } else if (sortBy === 'name') {
      result.sort((a, b) => a.text.localeCompare(b.text));
    }
    
    return result;
  }, [todos, filter, sortBy]);

  return (
    <div>
      <TodoFilters filter={filter} onFilterChange={setFilter} />
      <TodoSort sortBy={sortBy} onSortChange={setSortBy} />
      <TodoList todos={filteredTodos} />
    </div>
  );
}
```

#### 4. エラーハンドリング

```jsx
// ✅ 良い例：エラー境界を使用
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('エラーが発生しました:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>何か問題が発生しました。</h1>;
    }

    return this.props.children;
  }
}

// 使用例
<ErrorBoundary>
  <UserList />
</ErrorBoundary>
```

#### 5. パフォーマンス最適化

```jsx
// ✅ 良い例：React.memoで不要な再レンダリングを防ぐ
const UserCard = React.memo(function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>編集</button>
      <button onClick={() => onDelete(user.id)}>削除</button>
    </div>
  );
});

// ✅ 良い例：useCallbackで関数の再作成を防ぐ
function UserList() {
  const [users, setUsers] = useState([]);

  const handleEdit = useCallback((userId) => {
    // 編集ロジック
  }, []);

  const handleDelete = useCallback((userId) => {
    setUsers(prev => prev.filter(user => user.id !== userId));
  }, []);

  return (
    <div>
      {users.map(user => (
        <UserCard 
          key={user.id}
          user={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

### 9-6. 実践的なコンポーネント設計例
 [9-6.全体コード例はこちら](9章コード例.md#9-6-実践的なコンポーネント設計例)

この拡充された第9章では、以下の内容を詳細に説明しました：

1. **コンポーネント分割の理論と実践**
2. **Presentational/Container パターンの詳細**
3. **再利用パターン（HOC、Render Props、カスタムフック）**
4. **PropTypesの包括的な使用方法**
5. **ベストプラクティスとパフォーマンス最適化**
6. **完全な実践例（Todoアプリケーション）**

---
