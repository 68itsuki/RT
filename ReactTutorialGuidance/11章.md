## 第11章：実践的なアプリケーション開発

### 11-1. プロジェクト構造の設計

#### 11-1-1. フォルダ構造の重要性

実務では、プロジェクトの規模が大きくなるにつれて、コードの整理が重要になります。適切なフォルダ構造を設計することで、以下のメリットがあります：

- **保守性の向上**: 必要なファイルを素早く見つけられる
- **チーム開発の効率化**: 他の開発者が理解しやすい構造
- **スケーラビリティ**: 機能追加時の影響範囲を最小限に抑える
- **再利用性**: 共通コンポーネントの管理が容易

#### 11-1-2. 推奨フォルダ構造

```
src/
├── components/          # 再利用可能なコンポーネント
│   ├── common/         # 汎用的なコンポーネント（Button, Input, Modal等）
│   ├── forms/          # フォーム関連のコンポーネント
│   ├── layout/         # レイアウト関連のコンポーネント（Header, Footer, Sidebar等）
│   └── features/       # 機能別のコンポーネント（TodoItem, UserCard等）
├── hooks/              # カスタムフック
│   ├── api/            # API通信関連のフック
│   ├── form/           # フォーム関連のフック
│   └── ui/             # UI関連のフック
├── pages/              # ページコンポーネント（ルーティング単位）
├── services/           # API通信や外部サービス
│   ├── api/            # APIクライアント
│   └── external/       # 外部サービス（認証、分析等）
├── stores/             # 状態管理（Zustand, Redux等）
├── types/              # TypeScript型定義
│   ├── api/            # API関連の型定義
│   ├── components/     # コンポーネント関連の型定義
│   └── common/         # 共通の型定義
├── utils/              # ユーティリティ関数
│   ├── validation/     # バリデーション関数
│   ├── formatting/     # フォーマット関数
│   └── helpers/        # ヘルパー関数
├── styles/             # スタイルファイル
│   ├── global/         # グローバルスタイル
│   ├── components/     # コンポーネント別スタイル
│   └── themes/         # テーマ設定
├── constants/          # 定数定義
├── assets/             # 画像、アイコン等の静的ファイル
└── tests/              # テストファイル
```

#### 11-1-3. 命名規則の統一

**ファイル名の命名規則**
- コンポーネント: PascalCase（例：`TodoItem.tsx`）
- フック: camelCase（例：`useTodoList.ts`）
- ユーティリティ: camelCase（例：`formatDate.ts`）
- 定数: UPPER_SNAKE_CASE（例：`API_ENDPOINTS.ts`）

**フォルダ名の命名規則**
- すべて小文字（例：`components/`, `hooks/`）
- 複数形で統一（例：`components/`, `types/`）

### 11-2. 状態管理の実践

#### 11-2-1. 状態管理の選択基準

**小規模アプリケーション（1-3人開発）**
- React Context + useReducer
- Zustand（軽量で学習コストが低い）

**中規模アプリケーション（4-10人開発）**
- Zustand
- Redux Toolkit（複雑な状態管理が必要な場合）

**大規模アプリケーション（10人以上開発）**
- Redux Toolkit
- Recoil（Facebook製、実験的）
- Jotai（軽量でTypeScript対応）

#### 11-2-2. Zustandを使った状態管理

Zustandは、軽量で学習コストが低く、TypeScriptとの相性も良い状態管理ライブラリです。

**基本的なストアの作成**

```typescript
// stores/todoStore.ts
import { create } from 'zustand';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
  createdAt: Date;
}

interface TodoState {
  // 状態
  todos: Todo[];
  loading: boolean;
  error: string | null;
  filter: 'all' | 'active' | 'completed';
  
  // アクション
  fetchTodos: () => Promise<void>;
  addTodo: (text: string) => Promise<void>;
  toggleTodo: (id: number) => Promise<void>;
  deleteTodo: (id: number) => Promise<void>;
  setFilter: (filter: 'all' | 'active' | 'completed') => void;
  clearCompleted: () => void;
}

export const useTodoStore = create<TodoState>((set, get) => ({
  // 初期状態
  todos: [],
  loading: false,
  error: null,
  filter: 'all',
  
  // アクションの実装
  fetchTodos: async () => {
    set({ loading: true, error: null });
    try {
      const response = await fetch('/api/todos');
      if (!response.ok) {
        throw new Error('データの取得に失敗しました');
      }
      const todos = await response.json();
      set({ todos, loading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : '不明なエラーが発生しました',
        loading: false 
      });
    }
  },
  
  addTodo: async (text: string) => {
    const newTodo: Todo = {
      id: Date.now(),
      text: text.trim(),
      completed: false,
      createdAt: new Date()
    };
    
    // 楽観的更新（Optimistic Update）
    set(state => ({ todos: [...state.todos, newTodo] }));
    
    try {
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: newTodo.text })
      });
      
      if (!response.ok) {
        throw new Error('タスクの追加に失敗しました');
      }
      
      const savedTodo = await response.json();
      // サーバーから返されたデータで更新
      set(state => ({
        todos: state.todos.map(todo => 
          todo.id === newTodo.id ? savedTodo : todo
        )
      }));
    } catch (error) {
      // エラー時は楽観的更新を元に戻す
      set(state => ({
        todos: state.todos.filter(todo => todo.id !== newTodo.id),
        error: error instanceof Error ? error.message : '追加に失敗しました'
      }));
    }
  },
  
  toggleTodo: async (id: number) => {
    const currentTodos = get().todos;
    const todo = currentTodos.find(t => t.id === id);
    if (!todo) return;
    
    // 楽観的更新
    set(state => ({
      todos: state.todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    }));
    
    try {
      const response = await fetch(`/api/todos/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed: !todo.completed })
      });
      
      if (!response.ok) {
        throw new Error('タスクの更新に失敗しました');
      }
    } catch (error) {
      // エラー時は元に戻す
      set(state => ({
        todos: state.todos.map(todo =>
          todo.id === id ? { ...todo, completed: !todo.completed } : todo
        ),
        error: error instanceof Error ? error.message : '更新に失敗しました'
      }));
    }
  },
  
  deleteTodo: async (id: number) => {
    const currentTodos = get().todos;
    const todo = currentTodos.find(t => t.id === id);
    if (!todo) return;
    
    // 楽観的更新
    set(state => ({
      todos: state.todos.filter(todo => todo.id !== id)
    }));
    
    try {
      const response = await fetch(`/api/todos/${id}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error('タスクの削除に失敗しました');
      }
    } catch (error) {
      // エラー時は元に戻す
      set(state => ({
        todos: [...state.todos, todo],
        error: error instanceof Error ? error.message : '削除に失敗しました'
      }));
    }
  },
  
  setFilter: (filter: 'all' | 'active' | 'completed') => {
    set({ filter });
  },
  
  clearCompleted: () => {
    const completedTodos = get().todos.filter(todo => todo.completed);
    const completedIds = completedTodos.map(todo => todo.id);
    
    // 楽観的更新
    set(state => ({
      todos: state.todos.filter(todo => !todo.completed)
    }));
    
    // バックグラウンドで削除処理
    completedIds.forEach(async (id) => {
      try {
        await fetch(`/api/todos/${id}`, { method: 'DELETE' });
      } catch (error) {
        console.error(`タスク ${id} の削除に失敗:`, error);
      }
    });
  }
}));
```

#### 11-2-3. カスタムフックの作成

状態管理のロジックをカスタムフックに分離することで、コンポーネントをよりシンプルに保てます。

```typescript
// hooks/useTodoList.ts
import { useEffect, useMemo } from 'react';
import { useTodoStore } from '../stores/todoStore';

export const useTodoList = () => {
  const { 
    todos, 
    loading, 
    error, 
    filter, 
    fetchTodos, 
    setFilter 
  } = useTodoStore();
  
  // フィルタリングされたタスク
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed);
      case 'completed':
        return todos.filter(todo => todo.completed);
      default:
        return todos;
    }
  }, [todos, filter]);
  
  // 統計情報
  const stats = useMemo(() => {
    const total = todos.length;
    const completed = todos.filter(todo => todo.completed).length;
    const active = total - completed;
    
    return { total, completed, active };
  }, [todos]);
  
  // 初回読み込み
  useEffect(() => {
    fetchTodos();
  }, [fetchTodos]);
  
  return {
    todos: filteredTodos,
    loading,
    error,
    filter,
    stats,
    setFilter
  };
};
```

### 11-3. コンポーネント設計の実践

#### 11-3-1. コンポーネントの分割原則

**単一責任の原則**
- 1つのコンポーネントは1つの責任を持つ
- 複雑なコンポーネントは小さなコンポーネントに分割

**再利用性の向上**
- 汎用的なコンポーネントと具体的なコンポーネントを分離
- Propsで柔軟性を持たせる

#### 11-3-2. 実装例：TODOアプリケーション

**共通コンポーネント**

```typescript
// components/common/Button.tsx
import React from 'react';

interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick?: () => void;
  type?: 'button' | 'submit' | 'reset';
  className?: string;
}

export const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  size = 'medium',
  disabled = false,
  onClick,
  type = 'button',
  className = ''
}) => {
  const baseClasses = 'px-4 py-2 rounded font-medium transition-colors';
  
  const variantClasses = {
    primary: 'bg-blue-500 text-white hover:bg-blue-600',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',
    danger: 'bg-red-500 text-white hover:bg-red-600'
  };
  
  const sizeClasses = {
    small: 'px-2 py-1 text-sm',
    medium: 'px-4 py-2',
    large: 'px-6 py-3 text-lg'
  };
  
  const classes = [
    baseClasses,
    variantClasses[variant],
    sizeClasses[size],
    disabled && 'opacity-50 cursor-not-allowed',
    className
  ].filter(Boolean).join(' ');
  
  return (
    <button
      type={type}
      className={classes}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

```typescript
// components/common/Input.tsx
import React, { forwardRef } from 'react';

interface InputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  type?: 'text' | 'email' | 'password' | 'number';
  disabled?: boolean;
  error?: string;
  className?: string;
}

export const Input = forwardRef<HTMLInputElement, InputProps>(({
  value,
  onChange,
  placeholder,
  type = 'text',
  disabled = false,
  error,
  className = ''
}, ref) => {
  const baseClasses = 'px-3 py-2 border rounded focus:outline-none focus:ring-2';
  const errorClasses = error ? 'border-red-500' : 'border-gray-300';
  const disabledClasses = disabled ? 'bg-gray-100 cursor-not-allowed' : '';
  
  const classes = [
    baseClasses,
    errorClasses,
    disabledClasses,
    className
  ].filter(Boolean).join(' ');
  
  return (
    <div>
      <input
        ref={ref}
        type={type}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        disabled={disabled}
        className={classes}
      />
      {error && (
        <p className="text-red-500 text-sm mt-1">{error}</p>
      )}
    </div>
  );
});
```

**機能別コンポーネント**

```typescript
// components/features/TodoItem.tsx
import React from 'react';
import { Button } from '../common/Button';

interface TodoItemProps {
  id: number;
  text: string;
  completed: boolean;
  createdAt: Date;
  onToggle: (id: number) => void;
  onDelete: (id: number) => void;
}

export const TodoItem: React.FC<TodoItemProps> = ({
  id,
  text,
  completed,
  createdAt,
  onToggle,
  onDelete
}) => {
  const formatDate = (date: Date) => {
    return new Intl.DateTimeFormat('ja-JP', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }).format(date);
  };
  
  return (
    <div className="flex items-center justify-between p-4 border-b border-gray-200 hover:bg-gray-50">
      <div className="flex items-center space-x-3 flex-1">
        <input
          type="checkbox"
          checked={completed}
          onChange={() => onToggle(id)}
          className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
        />
        <div className="flex-1">
          <p className={`${completed ? 'line-through text-gray-500' : 'text-gray-900'}`}>
            {text}
          </p>
          <p className="text-xs text-gray-500">
            作成日: {formatDate(createdAt)}
          </p>
        </div>
      </div>
      <Button
        variant="danger"
        size="small"
        onClick={() => onDelete(id)}
      >
        削除
      </Button>
    </div>
  );
};
```

```typescript
// components/features/TodoList.tsx
import React from 'react';
import { TodoItem } from './TodoItem';
import { useTodoStore } from '../../stores/todoStore';

export const TodoList: React.FC = () => {
  const { todos, loading, error, toggleTodo, deleteTodo } = useTodoStore();
  
  if (loading) {
    return (
      <div className="flex justify-center items-center py-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
        <span className="ml-2">読み込み中...</span>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded p-4">
        <p className="text-red-800">エラー: {error}</p>
      </div>
    );
  }
  
  if (todos.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        タスクがありません。新しいタスクを追加してください。
      </div>
    );
  }
  
  return (
    <div className="space-y-2">
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          {...todo}
          onToggle={toggleTodo}
          onDelete={deleteTodo}
        />
      ))}
    </div>
  );
};
```

```typescript
// components/features/AddTodoForm.tsx
import React, { useState } from 'react';
import { Input } from '../common/Input';
import { Button } from '../common/Button';
import { useTodoStore } from '../../stores/todoStore';

export const AddTodoForm: React.FC = () => {
  const [text, setText] = useState('');
  const [error, setError] = useState('');
  const { addTodo } = useTodoStore();
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    
    if (!text.trim()) {
      setError('タスクの内容を入力してください');
      return;
    }
    
    if (text.length > 100) {
      setError('タスクは100文字以内で入力してください');
      return;
    }
    
    try {
      await addTodo(text.trim());
      setText('');
    } catch (error) {
      setError('タスクの追加に失敗しました');
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <Input
          value={text}
          onChange={setText}
          placeholder="新しいタスクを入力してください"
          error={error}
        />
      </div>
      <Button type="submit" disabled={!text.trim()}>
        タスクを追加
      </Button>
    </form>
  );
};
```

```typescript
// components/features/TodoStats.tsx
import React from 'react';
import { useTodoList } from '../../hooks/useTodoList';

export const TodoStats: React.FC = () => {
  const { stats, filter, setFilter } = useTodoList();
  
  const filterButtons = [
    { key: 'all' as const, label: 'すべて', count: stats.total },
    { key: 'active' as const, label: '未完了', count: stats.active },
    { key: 'completed' as const, label: '完了', count: stats.completed }
  ];
  
  return (
    <div className="bg-gray-50 p-4 rounded">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-medium">統計</h3>
        <div className="text-sm text-gray-600">
          合計: {stats.total} | 完了: {stats.completed} | 未完了: {stats.active}
        </div>
      </div>
      
      <div className="flex space-x-2">
        {filterButtons.map(({ key, label, count }) => (
          <button
            key={key}
            onClick={() => setFilter(key)}
            className={`px-3 py-1 rounded text-sm ${
              filter === key
                ? 'bg-blue-500 text-white'
                : 'bg-white text-gray-700 hover:bg-gray-100'
            }`}
          >
            {label} ({count})
          </button>
        ))}
      </div>
    </div>
  );
};
```

### 11-4. エラーハンドリングとユーザビリティ

#### 11-4-1. エラーバウンダリー

```typescript
// components/common/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
    // エラー監視サービスに送信
    // reportError(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-4 bg-red-50 border border-red-200 rounded">
          <h2 className="text-red-800 font-medium">エラーが発生しました</h2>
          <p className="text-red-600 text-sm mt-1">
            ページを再読み込みしてください。
          </p>
          <button
            onClick={() => window.location.reload()}
            className="mt-2 px-3 py-1 bg-red-600 text-white rounded text-sm"
          >
            再読み込み
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

#### 11-4-2. ローディング状態の管理

```typescript
// components/common/LoadingSpinner.tsx
import React from 'react';

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  text?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'medium',
  text = '読み込み中...'
}) => {
  const sizeClasses = {
    small: 'h-4 w-4',
    medium: 'h-8 w-8',
    large: 'h-12 w-12'
  };
  
  return (
    <div className="flex flex-col items-center justify-center py-8">
      <div className={`animate-spin rounded-full border-b-2 border-blue-500 ${sizeClasses[size]}`}></div>
      {text && <p className="mt-2 text-gray-600">{text}</p>}
    </div>
  );
};
```

### 11-5. パフォーマンス最適化

#### 11-5-1. React.memoによるメモ化

```typescript
// components/features/TodoItem.tsx（最適化版）
import React, { memo } from 'react';
import { Button } from '../common/Button';

interface TodoItemProps {
  id: number;
  text: string;
  completed: boolean;
  createdAt: Date;
  onToggle: (id: number) => void;
  onDelete: (id: number) => void;
}

export const TodoItem = memo<TodoItemProps>(({
  id,
  text,
  completed,
  createdAt,
  onToggle,
  onDelete
}) => {
  // コンポーネントの実装（前回と同じ）
  
  return (
    <div className="flex items-center justify-between p-4 border-b border-gray-200 hover:bg-gray-50">
      {/* 既存のJSX */}
    </div>
  );
});
```

#### 11-5-2. useCallbackとuseMemoの活用

```typescript
// hooks/useTodoList.ts（最適化版）
import { useEffect, useMemo, useCallback } from 'react';
import { useTodoStore } from '../stores/todoStore';

export const useTodoList = () => {
  const { 
    todos, 
    loading, 
    error, 
    filter, 
    fetchTodos, 
    setFilter 
  } = useTodoStore();
  
  // メモ化されたフィルタリング結果
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed);
      case 'completed':
        return todos.filter(todo => todo.completed);
      default:
        return todos;
    }
  }, [todos, filter]);
  
  // メモ化された統計情報
  const stats = useMemo(() => {
    const total = todos.length;
    const completed = todos.filter(todo => todo.completed).length;
    const active = total - completed;
    
    return { total, completed, active };
  }, [todos]);
  
  // メモ化されたフィルター変更関数
  const handleFilterChange = useCallback((newFilter: 'all' | 'active' | 'completed') => {
    setFilter(newFilter);
  }, [setFilter]);
  
  useEffect(() => {
    fetchTodos();
  }, [fetchTodos]);
  
  return {
    todos: filteredTodos,
    loading,
    error,
    filter,
    stats,
    setFilter: handleFilterChange
  };
};
```

### 11-6. テストの実装

#### 11-6-1. コンポーネントテスト

```typescript
// components/features/__tests__/TodoItem.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { TodoItem } from '../TodoItem';

const mockTodo = {
  id: 1,
  text: 'テストタスク',
  completed: false,
  createdAt: new Date('2024-01-01T00:00:00Z'),
  onToggle: jest.fn(),
  onDelete: jest.fn()
};

describe('TodoItem', () => {
  it('タスクの内容を表示する', () => {
    render(<TodoItem {...mockTodo} />);
    expect(screen.getByText('テストタスク')).toBeInTheDocument();
  });
  
  it('チェックボックスをクリックするとonToggleが呼ばれる', () => {
    render(<TodoItem {...mockTodo} />);
    const checkbox = screen.getByRole('checkbox');
    fireEvent.click(checkbox);
    expect(mockTodo.onToggle).toHaveBeenCalledWith(1);
  });
  
  it('削除ボタンをクリックするとonDeleteが呼ばれる', () => {
    render(<TodoItem {...mockTodo} />);
    const deleteButton = screen.getByText('削除');
    fireEvent.click(deleteButton);
    expect(mockTodo.onDelete).toHaveBeenCalledWith(1);
  });
  
  it('完了済みタスクは取り消し線が表示される', () => {
    const completedTodo = { ...mockTodo, completed: true };
    render(<TodoItem {...completedTodo} />);
    const taskText = screen.getByText('テストタスク');
    expect(taskText).toHaveClass('line-through');
  });
});
```

#### 11-6-2. カスタムフックのテスト

```typescript
// hooks/__tests__/useTodoList.test.ts
import { renderHook, act } from '@testing-library/react';
import { useTodoList } from '../useTodoList';
import { useTodoStore } from '../../stores/todoStore';

// モック
jest.mock('../../stores/todoStore');

describe('useTodoList', () => {
  const mockUseTodoStore = useTodoStore as jest.MockedFunction<typeof useTodoStore>;
  
  beforeEach(() => {
    mockUseTodoStore.mockReturnValue({
      todos: [
        { id: 1, text: 'タスク1', completed: false, createdAt: new Date() },
        { id: 2, text: 'タスク2', completed: true, createdAt: new Date() }
      ],
      loading: false,
      error: null,
      filter: 'all',
      fetchTodos: jest.fn(),
      setFilter: jest.fn()
    });
  });
  
  it('フィルタリングされたタスクを返す', () => {
    const { result } = renderHook(() => useTodoList());
    expect(result.current.todos).toHaveLength(2);
  });
  
  it('統計情報を正しく計算する', () => {
    const { result } = renderHook(() => useTodoList());
    expect(result.current.stats).toEqual({
      total: 2,
      completed: 1,
      active: 1
    });
  });
});
```

### 11-7. デプロイメントと本番環境

#### 11-7-1. 環境変数の管理

```typescript
// .env.local
REACT_APP_API_BASE_URL=http://localhost:3001/api
REACT_APP_ENVIRONMENT=development

// .env.production
REACT_APP_API_BASE_URL=https://api.example.com/api
REACT_APP_ENVIRONMENT=production
```

```typescript
// utils/config.ts
export const config = {
  apiBaseUrl: process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api',
  environment: process.env.REACT_APP_ENVIRONMENT || 'development',
  isDevelopment: process.env.REACT_APP_ENVIRONMENT === 'development',
  isProduction: process.env.REACT_APP_ENVIRONMENT === 'production'
};
```

#### 11-7-2. ビルド最適化

```json
// package.json
{
  "scripts": {
    "build": "GENERATE_SOURCEMAP=false react-scripts build",
    "build:analyze": "npm run build && npx serve -s build"
  }
}
```

### 11-8. アプリケーションの完成

```typescript
// App.tsx
import React from 'react';
import { ErrorBoundary } from './components/common/ErrorBoundary';
import { TodoList } from './components/features/TodoList';
import { AddTodoForm } from './components/features/AddTodoForm';
import { TodoStats } from './components/features/TodoStats';

function App() {
  return (
    <ErrorBoundary>
      <div className="min-h-screen bg-gray-50">
        <div className="max-w-2xl mx-auto py-8 px-4">
          <h1 className="text-3xl font-bold text-center mb-8 text-gray-800">
            TODOアプリケーション
          </h1>
          
          <div className="bg-white rounded-lg shadow-sm p-6 space-y-6">
            <AddTodoForm />
            <TodoStats />
            <TodoList />
          </div>
        </div>
      </div>
    </ErrorBoundary>
  );
}

export default App;
```

### 11-9. 実務でのベストプラクティス

#### 11-9-1. コードレビューのポイント

**コンポーネント設計**
- 単一責任の原則を守っているか
- 再利用可能なコンポーネントになっているか
- Propsの型定義は適切か

**パフォーマンス**
- 不要な再レンダリングが発生していないか
- メモ化を適切に使用しているか
- 大きなリストの場合は仮想化を検討しているか

**エラーハンドリング**
- 適切なエラーバウンダリーが設定されているか
- ユーザーフレンドリーなエラーメッセージを表示しているか
- ネットワークエラーに対する適切な処理があるか

#### 11-9-2. チーム開発での注意点

**命名規則の統一**
- コンポーネント名はPascalCase
- ファイル名はコンポーネント名と一致
- フォルダ名は小文字で複数形

**コミットメッセージの規約**
```
feat: 新しい機能の追加
fix: バグ修正
docs: ドキュメントの更新
style: コードスタイルの変更
refactor: リファクタリング
test: テストの追加・修正
chore: その他の変更
```

**ブランチ戦略**
- `main`: 本番環境
- `develop`: 開発環境
- `feature/機能名`: 新機能開発
- `hotfix/修正内容`: 緊急修正

この拡充により、React初心者でも実務で使える包括的な知識を身につけることができます。基本概念から実践的なパターンまで、段階的に学習できる構成になっています。