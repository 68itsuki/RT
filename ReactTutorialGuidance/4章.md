## 第4章：ステート管理の基本

### 4-1. ステート管理の基本概念

#### ステートとは何か？

ステート（state）は、コンポーネントが持つ「変化する値」のことです。ユーザーの操作や時間の経過によって変化するデータを管理するために使用されます。

```jsx
// ステートの例
function UserProfile() {
  const [name, setName] = useState('田中太郎');
  const [age, setAge] = useState(25);
  const [isLoggedIn, setIsLoggedIn] = useState(true);
  const [todos, setTodos] = useState([]);
  
  return (
    <div>
      <h2>{name}</h2>
      <p>年齢: {age}歳</p>
      <p>ステータス: {isLoggedIn ? 'ログイン中' : 'ログアウト'}</p>
      <p>タスク数: {todos.length}個</p>
    </div>
  );
}
```

#### ステートの特徴

**1. イミュータブル（不変性）**
- ステートは直接変更せず、更新関数を使って変更する
- これにより、Reactが変更を検知して再レンダリングできる

**2. 非同期更新**
- ステートの更新は非同期で行われる
- 複数の更新がバッチ処理される

**3. コンポーネント固有**
- 各コンポーネントは独自のステートを持つ
- 親子間でステートは共有されない

### 4-2. `useState`の詳細

#### 基本的な使い方

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    setCount(count + 1);
  };
  
  const decrement = () => {
    setCount(count - 1);
  };
  
  const reset = () => {
    setCount(0);
  };
  
  return (
    <div>
      <h2>カウンター</h2>
      <p>現在の値: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>リセット</button>
    </div>
  );
}
```

#### 初期値の設定

```jsx
// プリミティブ値
const [count, setCount] = useState(0);
const [name, setName] = useState('');
const [isActive, setIsActive] = useState(false);

// オブジェクト
const [user, setUser] = useState({
  name: '',
  email: '',
  age: 0
});

// 配列
const [items, setItems] = useState([]);
const [numbers, setNumbers] = useState([1, 2, 3]);

// 関数による初期値（遅延初期化）
const [expensiveValue, setExpensiveValue] = useState(() => {
  // 重い計算を初期化時のみ実行
  return calculateExpensiveValue();
});
```

#### 関数による初期化

```jsx
function TodoList() {
  // ローカルストレージから初期値を取得
  const [todos, setTodos] = useState(() => {
    const savedTodos = localStorage.getItem('todos');
    return savedTodos ? JSON.parse(savedTodos) : [];
  });
  
  // 複雑な初期化処理
  const [config, setConfig] = useState(() => {
    const defaultConfig = {
      theme: 'light',
      language: 'ja',
      notifications: true
    };
    
    // ユーザー設定があれば読み込み
    const userConfig = localStorage.getItem('userConfig');
    if (userConfig) {
      return { ...defaultConfig, ...JSON.parse(userConfig) };
    }
    
    return defaultConfig;
  });
  
  return (
    <div>
      <h2>タスク一覧</h2>
      <p>タスク数: {todos.length}</p>
      <p>テーマ: {config.theme}</p>
    </div>
  );
}
```

### 4-3. 状態更新のパターン

#### 基本的な更新

```jsx
function BasicUpdates() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  const [isVisible, setIsVisible] = useState(true);
  
  // プリミティブ値の更新
  const increment = () => setCount(count + 1);
  const updateName = (newName) => setName(newName);
  const toggleVisibility = () => setIsVisible(!isVisible);
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>増加</button>
      
      <input 
        value={name} 
        onChange={(e) => updateName(e.target.value)}
        placeholder="名前を入力"
      />
      
      <button onClick={toggleVisibility}>
        {isVisible ? '非表示' : '表示'}
      </button>
      
      {isVisible && <p>このテキストは表示されています</p>}
    </div>
  );
}
```

#### 関数による更新

```jsx
function FunctionalUpdates() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([]);
  
  // 関数による更新（推奨）
  const increment = () => {
    setCount(prevCount => prevCount + 1);
  };
  
  const incrementBy = (amount) => {
    setCount(prevCount => prevCount + amount);
  };
  
  const addItem = (newItem) => {
    setItems(prevItems => [...prevItems, newItem]);
  };
  
  const removeItem = (id) => {
    setItems(prevItems => prevItems.filter(item => item.id !== id));
  };
  
  const updateItem = (itemId, updates) => {
    setItems(prevItems => 
      prevItems.map(item => 
        item.id === itemId ? { ...item, ...updates } : item
      )
    );
  };
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={() => incrementBy(5)}>+5</button>
      
      <h3>アイテム一覧</h3>
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.name}
            <button onClick={() => removeItem(item.id)}>削除</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### オブジェクトの更新

```jsx
function ObjectUpdates() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0,
    preferences: {
      theme: 'light',
      notifications: true
    }
  });
  
  // オブジェクトの更新（スプレッド演算子使用）
  const updateName = (name) => {
    setUser(prevUser => ({
      ...prevUser,
      name
    }));
  };
  
  const updateEmail = (email) => {
    setUser(prevUser => ({
      ...prevUser,
      email
    }));
  };
  
  // ネストしたオブジェクトの更新
  const updateTheme = (theme) => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        theme
      }
    }));
  };
  
  const toggleNotifications = () => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        notifications: !prevUser.preferences.notifications
      }
    }));
  };
  
  return (
    <div>
      <h2>ユーザー設定</h2>
      
      <div>
        <label>名前:</label>
        <input
          value={user.name}
          onChange={(e) => updateName(e.target.value)}
        />
      </div>
      
      <div>
        <label>メール:</label>
        <input
          type="email"
          value={user.email}
          onChange={(e) => updateEmail(e.target.value)}
        />
      </div>
      
      <div>
        <label>テーマ:</label>
        <select 
          value={user.preferences.theme}
          onChange={(e) => updateTheme(e.target.value)}
        >
          <option value="light">ライト</option>
          <option value="dark">ダーク</option>
        </select>
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            checked={user.preferences.notifications}
            onChange={toggleNotifications}
          />
          通知を有効にする
        </label>
      </div>
      
      <pre>{JSON.stringify(user, null, 2)}</pre>
    </div>
  );
}
```

#### 配列の更新

```jsx
function ArrayUpdates() {
  const [todos, setTodos] = useState([]);
  const [newTodo, setNewTodo] = useState('');
  
  // 配列に要素を追加
  const addTodo = () => {
    if (newTodo.trim()) {
      const todo = {
        id: Date.now(),
        text: newTodo.trim(),
        completed: false
      };
      
      setTodos(prevTodos => [...prevTodos, todo]);
      setNewTodo('');
    }
  };
  
  // 配列から要素を削除
  const removeTodo = (id) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
  };
  
  // 配列の要素を更新
  const toggleTodo = (id) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };
  
  // 配列の要素を並び替え
  const moveTodo = (fromIndex, toIndex) => {
    setTodos(prevTodos => {
      const newTodos = [...prevTodos];
      const [movedTodo] = newTodos.splice(fromIndex, 1);
      newTodos.splice(toIndex, 0, movedTodo);
      return newTodos;
    });
  };
  
  return (
    <div>
      <h2>TODOリスト</h2>
      
      <div>
        <input
          value={newTodo}
          onChange={(e) => setNewTodo(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addTodo()}
          placeholder="新しいタスクを入力"
        />
        <button onClick={addTodo}>追加</button>
      </div>
      
      <ul>
        {todos.map((todo, index) => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{
              textDecoration: todo.completed ? 'line-through' : 'none'
            }}>
              {todo.text}
            </span>
            <button onClick={() => removeTodo(todo.id)}>削除</button>
            {index > 0 && (
              <button onClick={() => moveTodo(index, index - 1)}>↑</button>
            )}
            {index < todos.length - 1 && (
              <button onClick={() => moveTodo(index, index + 1)}>↓</button>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 4-4. 複数のステートの管理

#### 個別のステート

```jsx
function IndividualStates() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    setErrors({});
    
    try {
      // バリデーション
      const newErrors = {};
      if (!name) newErrors.name = '名前は必須です';
      if (!email) newErrors.email = 'メールアドレスは必須です';
      if (age < 0) newErrors.age = '年齢は0以上で入力してください';
      
      if (Object.keys(newErrors).length > 0) {
        setErrors(newErrors);
        return;
      }
      
      // 送信処理
      await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, email, age })
      });
      
      // 成功時の処理
      setName('');
      setEmail('');
      setAge(0);
      alert('送信完了！');
      
    } catch (error) {
      setErrors({ submit: '送信に失敗しました' });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>名前:</label>
        <input
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
        {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
      </div>
      
      <div>
        <label>メール:</label>
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>
      
      <div>
        <label>年齢:</label>
        <input
          type="number"
          value={age}
          onChange={(e) => setAge(Number(e.target.value))}
        />
        {errors.age && <span style={{ color: 'red' }}>{errors.age}</span>}
      </div>
      
      {errors.submit && (
        <div style={{ color: 'red' }}>{errors.submit}</div>
      )}
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '送信中...' : '送信'}
      </button>
    </form>
  );
}
```

#### オブジェクトによる統合

```jsx
function UnifiedState() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    age: 0
  });
  
  const [formState, setFormState] = useState({
    isSubmitting: false,
    errors: {}
  });
  
  const updateField = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };
  
  const setError = (field, message) => {
    setFormState(prev => ({
      ...prev,
      errors: {
        ...prev.errors,
        [field]: message
      }
    }));
  };
  
  const clearErrors = () => {
    setFormState(prev => ({
      ...prev,
      errors: {}
    }));
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setFormState(prev => ({ ...prev, isSubmitting: true }));
    clearErrors();
    
    try {
      // バリデーション
      const newErrors = {};
      if (!formData.name) newErrors.name = '名前は必須です';
      if (!formData.email) newErrors.email = 'メールアドレスは必須です';
      if (formData.age < 0) newErrors.age = '年齢は0以上で入力してください';
      
      if (Object.keys(newErrors).length > 0) {
        setFormState(prev => ({
          ...prev,
          errors: newErrors
        }));
        return;
      }
      
      // 送信処理
      await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      // 成功時の処理
      setFormData({ name: '', email: '', age: 0 });
      alert('送信完了！');
      
    } catch (error) {
      setFormState(prev => ({
        ...prev,
        errors: { submit: '送信に失敗しました' }
      }));
    } finally {
      setFormState(prev => ({ ...prev, isSubmitting: false }));
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>名前:</label>
        <input
          value={formData.name}
          onChange={(e) => updateField('name', e.target.value)}
        />
        {formState.errors.name && (
          <span style={{ color: 'red' }}>{formState.errors.name}</span>
        )}
      </div>
      
      <div>
        <label>メール:</label>
        <input
          type="email"
          value={formData.email}
          onChange={(e) => updateField('email', e.target.value)}
        />
        {formState.errors.email && (
          <span style={{ color: 'red' }}>{formState.errors.email}</span>
        )}
      </div>
      
      <div>
        <label>年齢:</label>
        <input
          type="number"
          value={formData.age}
          onChange={(e) => updateField('age', Number(e.target.value))}
        />
        {formState.errors.age && (
          <span style={{ color: 'red' }}>{formState.errors.age}</span>
        )}
      </div>
      
      {formState.errors.submit && (
        <div style={{ color: 'red' }}>{formState.errors.submit}</div>
      )}
      
      <button type="submit" disabled={formState.isSubmitting}>
        {formState.isSubmitting ? '送信中...' : '送信'}
      </button>
    </form>
  );
}
```

### 4-5. カスタムフックによる状態管理

#### 基本的なカスタムフック

```jsx
// hooks/useCounter.js
import { useState, useCallback } from 'react';

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  const decrement = useCallback(() => {
    setCount(prev => prev - 1);
  }, []);
  
  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);
  
  const setValue = useCallback((value) => {
    setCount(value);
  }, []);
  
  return {
    count,
    increment,
    decrement,
    reset,
    setValue
  };
}

// 使用例
function CounterWithHook() {
  const { count, increment, decrement, reset } = useCounter(10);
  
  return (
    <div>
      <h2>カウンター: {count}</h2>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>リセット</button>
    </div>
  );
}
```

#### フォーム管理用のカスタムフック

```jsx
// hooks/useForm.js
import { useState, useCallback } from 'react';

function useForm(initialValues = {}) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = useCallback((field, value) => {
    setValues(prev => ({
      ...prev,
      [field]: value
    }));
    
    // エラーをクリア
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: ''
      }));
    }
  }, [errors]);
  
  const setError = useCallback((field, message) => {
    setErrors(prev => ({
      ...prev,
      [field]: message
    }));
  }, []);
  
  const setErrors = useCallback((newErrors) => {
    setErrors(newErrors);
  }, []);
  
  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setIsSubmitting(false);
  }, [initialValues]);
  
  const handleSubmit = useCallback(async (submitFunction) => {
    setIsSubmitting(true);
    setErrors({});
    
    try {
      await submitFunction(values);
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [values]);
  
  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    setError,
    setErrors,
    reset,
    handleSubmit
  };
}

// 使用例
function UserForm() {
  const {
    values,
    errors,
    isSubmitting,
    handleChange,
    setError,
    handleSubmit
  } = useForm({
    name: '',
    email: '',
    age: 0
  });
  
  const onSubmit = async (formData) => {
    // バリデーション
    if (!formData.name) {
      setError('name', '名前は必須です');
      return;
    }
    if (!formData.email) {
      setError('email', 'メールアドレスは必須です');
      return;
    }
    
    // 送信処理
    await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(formData)
    });
    
    alert('送信完了！');
  };
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      handleSubmit(onSubmit);
    }}>
      <div>
        <label>名前:</label>
        <input
          value={values.name}
          onChange={(e) => handleChange('name', e.target.value)}
        />
        {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
      </div>
      
      <div>
        <label>メール:</label>
        <input
          type="email"
          value={values.email}
          onChange={(e) => handleChange('email', e.target.value)}
        />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>
      
      <div>
        <label>年齢:</label>
        <input
          type="number"
          value={values.age}
          onChange={(e) => handleChange('age', Number(e.target.value))}
        />
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '送信中...' : '送信'}
      </button>
    </form>
  );
}
```

### 4-6. パフォーマンス最適化

#### 不要な再レンダリングの防止

```jsx
import React, { memo, useCallback, useMemo } from 'react';

// メモ化されたコンポーネント
const ExpensiveComponent = memo(({ data, onUpdate }) => {
  console.log('ExpensiveComponent rendered');
  
  // 重い計算をメモ化
  const processedData = useMemo(() => {
    console.log('Processing data...');
    return data.map(item => ({
      ...item,
      processed: item.value * 2
    }));
  }, [data]);
  
  return (
    <div>
      {processedData.map(item => (
        <div key={item.id}>
          {item.name}: {item.processed}
        </div>
      ))}
      <button onClick={onUpdate}>更新</button>
    </div>
  );
});

// 親コンポーネント
function ParentComponent() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState([
    { id: 1, name: 'アイテム1', value: 10 },
    { id: 2, name: 'アイテム2', value: 20 }
  ]);
  
  // 関数をメモ化
  const handleUpdate = useCallback(() => {
    console.log('Updating data...');
    setData(prev => prev.map(item => ({
      ...item,
      value: item.value + 1
    })));
  }, []);
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        カウント増加
      </button>
      
      <ExpensiveComponent 
        data={data} 
        onUpdate={handleUpdate} 
      />
    </div>
  );
}
```

#### 状態の正規化

```jsx
function NormalizedState() {
  // ❌ 悪い例：ネストしたデータ
  const [badState, setBadState] = useState({
    posts: [
      {
        id: 1,
        title: '投稿1',
        author: {
          id: 1,
          name: '田中',
          email: 'tanaka@example.com'
        },
        comments: [
          {
            id: 1,
            text: 'コメント1',
            user: {
              id: 2,
              name: '佐藤'
            }
          }
        ]
      }
    ]
  });
  
  // ✅ 良い例：正規化されたデータ
  const [normalizedState, setNormalizedState] = useState({
    posts: {
      byId: {
        1: { id: 1, title: '投稿1', authorId: 1, commentIds: [1] }
      },
      allIds: [1]
    },
    users: {
      byId: {
        1: { id: 1, name: '田中', email: 'tanaka@example.com' },
        2: { id: 2, name: '佐藤' }
      },
      allIds: [1, 2]
    },
    comments: {
      byId: {
        1: { id: 1, text: 'コメント1', userId: 2, postId: 1 }
      },
      allIds: [1]
    }
  });
  
  // セレクター関数
  const selectPost = (state, postId) => {
    const post = state.posts.byId[postId];
    if (!post) return null;
    
    return {
      ...post,
      author: state.users.byId[post.authorId],
      comments: post.commentIds.map(id => ({
        ...state.comments.byId[id],
        user: state.users.byId[state.comments.byId[id].userId]
      }))
    };
  };
  
  const post = selectPost(normalizedState, 1);
  
  return (
    <div>
      <h2>{post?.title}</h2>
      <p>著者: {post?.author?.name}</p>
      <h3>コメント</h3>
      {post?.comments?.map(comment => (
        <div key={comment.id}>
          <p>{comment.text}</p>
          <small>by {comment.user.name}</small>
        </div>
      ))}
    </div>
  );
}
```

### 4-7. デバッグと開発者ツール

#### ステートの可視化

```jsx
function StateDebugger({ state, label = 'State' }) {
  const [isExpanded, setIsExpanded] = useState(false);
  
  return (
    <div style={{ 
      border: '1px solid #ccc', 
      padding: '10px', 
      margin: '10px 0',
      backgroundColor: '#f9f9f9'
    }}>
      <button onClick={() => setIsExpanded(!isExpanded)}>
        {isExpanded ? '▼' : '▶'} {label}
      </button>
      
      {isExpanded && (
        <pre style={{ 
          fontSize: '12px', 
          overflow: 'auto',
          maxHeight: '200px'
        }}>
          {JSON.stringify(state, null, 2)}
        </pre>
      )}
    </div>
  );
}

// 使用例
function DebugExample() {
  const [user, setUser] = useState({
    name: '田中太郎',
    age: 25,
    preferences: {
      theme: 'light',
      notifications: true
    }
  });
  
  const [todos, setTodos] = useState([
    { id: 1, text: '買い物', completed: false },
    { id: 2, text: '掃除', completed: true }
  ]);
  
  return (
    <div>
      <h2>デバッグ例</h2>
      
      <StateDebugger state={user} label="User State" />
      <StateDebugger state={todos} label="Todos State" />
      
      <button onClick={() => setUser(prev => ({ ...prev, age: prev.age + 1 }))}>
        年齢を増加
      </button>
      
      <button onClick={() => setTodos(prev => [...prev, { 
        id: Date.now(), 
        text: '新しいタスク', 
        completed: false 
      }])}>
        タスクを追加
      </button>
    </div>
  );
}
```

#### ステート変更の追跡

```jsx
function useStateLogger(initialState, label = 'State') {
  const [state, setState] = useState(initialState);
  
  const setStateWithLogging = useCallback((newState) => {
    console.group(`${label} Update`);
    console.log('Previous State:', state);
    console.log('New State:', newState);
    console.log('Update Type:', typeof newState === 'function' ? 'Function' : 'Value');
    console.groupEnd();
    
    setState(newState);
  }, [state, label]);
  
  return [state, setStateWithLogging];
}

// 使用例
function StateLoggerExample() {
  const [count, setCount] = useStateLogger(0, 'Counter');
  const [user, setUser] = useStateLogger({
    name: '',
    email: ''
  }, 'User');
  
  const increment = () => setCount(prev => prev + 1);
  const updateName = (name) => setUser(prev => ({ ...prev, name }));
  
  return (
    <div>
      <h2>ステートロガー例</h2>
      
      <div>
        <p>カウント: {count}</p>
        <button onClick={increment}>増加</button>
      </div>
      
      <div>
        <input
          value={user.name}
          onChange={(e) => updateName(e.target.value)}
          placeholder="名前を入力"
        />
        <p>名前: {user.name}</p>
      </div>
    </div>
  );
}
```

### 4-8. ベストプラクティス

#### ステート設計の原則

```jsx
// ✅ 良い例：最小限のステート
function GoodStateDesign() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');
  
  // フィルタリングされたtodosは計算で求める
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'completed':
        return todos.filter(todo => todo.completed);
      case 'active':
        return todos.filter(todo => !todo.completed);
      default:
        return todos;
    }
  }, [todos, filter]);
  
  // 完了済みの数も計算で求める
  const completedCount = useMemo(() => {
    return todos.filter(todo => todo.completed).length;
  }, [todos]);
  
  return (
    <div>
      <div>
        <button onClick={() => setFilter('all')}>すべて</button>
        <button onClick={() => setFilter('active')}>未完了</button>
        <button onClick={() => setFilter('completed')}>完了済み</button>
      </div>
      
      <p>完了済み: {completedCount}/{todos.length}</p>
      
      <ul>
        {filteredTodos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}

// ❌ 悪い例：冗長なステート
function BadStateDesign() {
  const [todos, setTodos] = useState([]);
  const [filteredTodos, setFilteredTodos] = useState([]);
  const [completedCount, setCompletedCount] = useState(0);
  const [activeCount, setActiveCount] = useState(0);
  
  // ステートの同期が複雑になる
  useEffect(() => {
    const filtered = todos.filter(todo => todo.completed);
    setFilteredTodos(filtered);
    setCompletedCount(filtered.length);
    setActiveCount(todos.length - filtered.length);
  }, [todos]);
  
  return (
    <div>
      <p>完了済み: {completedCount}/{todos.length}</p>
      <p>未完了: {activeCount}</p>
      
      <ul>
        {filteredTodos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### ステート更新のパターン

```jsx
// ✅ 良い例：関数による更新
function GoodUpdatePatterns() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([]);
  
  // 関数による更新（推奨）
  const increment = () => setCount(prev => prev + 1);
  const addItem = (newItem) => setItems(prev => [...prev, newItem]);
  const removeItem = (id) => setItems(prev => prev.filter(item => item.id !== id));
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>増加</button>
      
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.name}
            <button onClick={() => removeItem(item.id)}>削除</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

// ❌ 悪い例：直接的な更新
function BadUpdatePatterns() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([]);
  
  // 直接的な更新（避けるべき）
  const increment = () => {
    const newCount = count + 1; // 古い値を使用
    setCount(newCount);
  };
  
  const addItem = (newItem) => {
    const newItems = [...items, newItem]; // 古い配列を使用
    setItems(newItems);
  };
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>増加</button>
    </div>
  );
}
```