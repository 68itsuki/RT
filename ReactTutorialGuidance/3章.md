## 第3章：コンポーネントの基礎

### 3-1. コンポーネントの基本概念

#### コンポーネントとは何か？

コンポーネントは、UIの一部分を表す再利用可能なコードの塊です。Reactアプリケーションは、小さなコンポーネントを組み合わせて構築されます。

```jsx
// 基本的なコンポーネント
function Welcome() {
  return <h1>こんにちは！</h1>;
}

// 使用例
function App() {
  return (
    <div>
      <Welcome />
      <Welcome />
      <Welcome />
    </div>
  );
}
```

#### コンポーネントの利点

**1. 再利用性**
- 同じコンポーネントを複数の場所で使用できる
- コードの重複を避けられる

**2. 保守性**
- 小さな単位に分割することで、修正や機能追加が容易
- バグの特定と修正が簡単

**3. テストしやすさ**
- 個別のコンポーネントを独立してテストできる
- ユニットテストが書きやすい

**4. チーム開発**
- 複数の開発者が異なるコンポーネントを並行して開発可能
- 責任の分離が明確

### 3-2. 関数コンポーネントとクラスコンポーネント

#### 関数コンポーネント（現在主流）

関数コンポーネントは、JavaScriptの関数として定義されるコンポーネントです。現在のReact開発では主流となっています。

```jsx
// 基本的な関数コンポーネント
function Greeting() {
  return <h1>こんにちは！</h1>;
}

// アロー関数での定義
const Greeting = () => {
  return <h1>こんにちは！</h1>;
};

// 暗黙的なreturn
const Greeting = () => <h1>こんにちは！</h1>;
```

#### クラスコンポーネント（レガシー）

クラスコンポーネントは、ES6のクラス構文を使用したコンポーネントです。現在は関数コンポーネントとHooksの組み合わせが推奨されています。

```jsx
class Greeting extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: 'こんにちは！'
    };
  }
  
  render() {
    return <h1>{this.state.message}</h1>;
  }
}
```

#### 関数コンポーネント vs クラスコンポーネント

| 特徴 | 関数コンポーネント | クラスコンポーネント |
|------|-------------------|---------------------|
| **構文** | シンプル | 複雑 |
| **学習コスト** | 低い | 高い |
| **バンドルサイズ** | 小さい | 大きい |
| **Hooks対応** | 完全対応 | 部分的対応 |
| **パフォーマンス** | 最適化されている | 従来の最適化 |
| **将来性** | 推奨 | レガシー |

### 3-3. Propsの詳細

#### Propsの基本

Propsは、親コンポーネントから子コンポーネントにデータを渡すための仕組みです。

```jsx
// 親コンポーネント
function ParentComponent() {
  const user = {
    name: '田中太郎',
    age: 25,
    email: 'tanaka@example.com'
  };
  
  return (
    <div>
      <UserProfile user={user} />
      <UserCard name="佐藤花子" age={30} />
    </div>
  );
}

// 子コンポーネント
function UserProfile({ user }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>年齢: {user.age}歳</p>
      <p>メール: {user.email}</p>
    </div>
  );
}

function UserCard({ name, age }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>年齢: {age}歳</p>
    </div>
  );
}
```

#### Propsの分割代入

```jsx
// 基本的な分割代入
function Welcome({ name, age, city }) {
  return (
    <div>
      <h1>こんにちは、{name}さん！</h1>
      <p>年齢: {age}歳</p>
      <p>居住地: {city}</p>
    </div>
  );
}

// デフォルト値の設定
function Button({ 
  text = 'ボタン', 
  onClick, 
  disabled = false,
  variant = 'primary' 
}) {
  return (
    <button 
      onClick={onClick}
      disabled={disabled}
      className={`btn btn-${variant}`}
    >
      {text}
    </button>
  );
}

// 残りのpropsを展開
function Card({ title, children, ...restProps }) {
  return (
    <div className="card" {...restProps}>
      <h3>{title}</h3>
      <div className="card-body">
        {children}
      </div>
    </div>
  );
}
```

#### Propsの型チェック（PropTypes）

```jsx
import PropTypes from 'prop-types';

function UserProfile({ user, showEmail, onEdit }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>年齢: {user.age}歳</p>
      {showEmail && <p>メール: {user.email}</p>}
      <button onClick={onEdit}>編集</button>
    </div>
  );
}

// PropTypesによる型チェック
UserProfile.propTypes = {
  user: PropTypes.shape({
    name: PropTypes.string.isRequired,
    age: PropTypes.number.isRequired,
    email: PropTypes.string
  }).isRequired,
  showEmail: PropTypes.bool,
  onEdit: PropTypes.func
};

// デフォルト値
UserProfile.defaultProps = {
  showEmail: false,
  onEdit: () => {}
};
```

#### 条件付きProps

```jsx
function ConditionalProps({ user, isAdmin, theme }) {
  const cardStyle = {
    padding: '20px',
    borderRadius: '8px',
    backgroundColor: theme === 'dark' ? '#333' : '#fff',
    color: theme === 'dark' ? '#fff' : '#333'
  };
  
  return (
    <div style={cardStyle}>
      <h2>{user.name}</h2>
      <p>年齢: {user.age}歳</p>
      
      {/* 条件付きで表示 */}
      {isAdmin && (
        <div>
          <p>管理者権限</p>
          <button>ユーザー管理</button>
        </div>
      )}
      
      {/* 条件付きでpropsを渡す */}
      <UserActions 
        user={user}
        {...(isAdmin && { canDelete: true })}
        {...(theme === 'dark' && { darkMode: true })}
      />
    </div>
  );
}
```

### 3-4. コンポーネントの設計パターン

#### Presentational Component（表示コンポーネント）

表示コンポーネントは、UIの表示のみを担当し、ビジネスロジックを持たないコンポーネントです。

```jsx
// 表示コンポーネントの例
function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <div className="actions">
        <button onClick={() => onEdit(user.id)}>編集</button>
        <button onClick={() => onDelete(user.id)}>削除</button>
      </div>
    </div>
  );
}

function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span>{todo.text}</span>
      <button onClick={() => onDelete(todo.id)}>削除</button>
    </li>
  );
}
```

#### Container Component（コンテナコンポーネント）

コンテナコンポーネントは、データの取得や状態管理を担当し、表示コンポーネントにデータを渡します。

```jsx
// コンテナコンポーネントの例
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchUsers();
  }, []);
  
  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/users');
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  const handleEdit = (userId) => {
    // 編集処理
    console.log('編集:', userId);
  };
  
  const handleDelete = async (userId) => {
    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      setUsers(users.filter(user => user.id !== userId));
    } catch (err) {
      console.error('削除エラー:', err);
    }
  };
  
  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;
  
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

#### Higher-Order Component（HOC）

HOCは、コンポーネントを受け取って新しいコンポーネントを返す関数です。

```jsx
// ローディング状態を管理するHOC
function withLoading(WrappedComponent) {
  return function WithLoadingComponent({ loading, ...props }) {
    if (loading) {
      return <div>読み込み中...</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

// エラーハンドリングを追加するHOC
function withErrorHandling(WrappedComponent) {
  return function WithErrorHandlingComponent({ error, ...props }) {
    if (error) {
      return <div>エラー: {error}</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

// 使用例
const UserListWithLoading = withLoading(UserList);
const UserListWithError = withErrorHandling(UserListWithLoading);

function App() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  return (
    <UserListWithError
      loading={loading}
      error={error}
    />
  );
}
```

#### Render Props パターン

Render Propsは、コンポーネントの子要素として関数を渡すパターンです。

```jsx
// データフェッチング用のRender Propsコンポーネント
function DataFetcher({ url, children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchData();
  }, [url]);
  
  const fetchData = async () => {
    try {
      setLoading(true);
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  return children({ data, loading, error, refetch: fetchData });
}

// 使用例
function UserList() {
  return (
    <DataFetcher url="/api/users">
      {({ data, loading, error, refetch }) => {
        if (loading) return <div>読み込み中...</div>;
        if (error) return <div>エラー: {error}</div>;
        
        return (
          <div>
            <button onClick={refetch}>再読み込み</button>
            {data.map(user => (
              <UserCard key={user.id} user={user} />
            ))}
          </div>
        );
      }}
    </DataFetcher>
  );
}
```

### 3-5. コンポーネントのライフサイクル

#### 関数コンポーネントのライフサイクル（Hooks）

```jsx
import { useState, useEffect, useRef } from 'react';

function LifecycleExample() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState(null);
  const intervalRef = useRef(null);
  
  // マウント時のみ実行
  useEffect(() => {
    console.log('コンポーネントがマウントされました');
    
    // クリーンアップ関数
    return () => {
      console.log('コンポーネントがアンマウントされます');
    };
  }, []);
  
  // countが変更されるたびに実行
  useEffect(() => {
    console.log('countが変更されました:', count);
  }, [count]);
  
  // データフェッチング
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('/api/data');
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error('データ取得エラー:', error);
      }
    };
    
    fetchData();
  }, []);
  
  // タイマーの設定
  useEffect(() => {
    intervalRef.current = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
    
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
  
  return (
    <div>
      <h2>カウント: {count}</h2>
      {data && <p>データ: {JSON.stringify(data)}</p>}
      <button onClick={() => setCount(count + 1)}>
        手動で増加
      </button>
    </div>
  );
}
```

#### カスタムフックでのライフサイクル管理

```jsx
// データフェッチング用のカスタムフック
function useDataFetching(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  const refetch = () => {
    setLoading(true);
    setError(null);
    fetch(url)
      .then(response => response.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  };
  
  return { data, loading, error, refetch };
}

// 使用例
function UserList() {
  const { data: users, loading, error, refetch } = useDataFetching('/api/users');
  
  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;
  
  return (
    <div>
      <button onClick={refetch}>再読み込み</button>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

### 3-6. コンポーネントの最適化

#### React.memoによるメモ化

```jsx
import React, { memo } from 'react';

// メモ化されたコンポーネント
const ExpensiveComponent = memo(({ data, onUpdate }) => {
  console.log('ExpensiveComponent rendered');
  
  return (
    <div>
      {data.map(item => (
        <div key={item.id}>
          {item.name}: {item.value}
        </div>
      ))}
      <button onClick={onUpdate}>更新</button>
    </div>
  );
});

// カスタム比較関数
const UserCard = memo(({ user, onEdit }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>編集</button>
    </div>
  );
}, (prevProps, nextProps) => {
  // カスタム比較ロジック
  return (
    prevProps.user.id === nextProps.user.id &&
    prevProps.user.name === nextProps.user.name &&
    prevProps.user.email === nextProps.user.email
  );
});
```

#### useMemoとuseCallbackの活用

```jsx
import React, { useState, useMemo, useCallback } from 'react';

function OptimizedComponent({ users, filterText }) {
  const [selectedUser, setSelectedUser] = useState(null);
  
  // 重い計算をメモ化
  const filteredUsers = useMemo(() => {
    console.log('フィルタリング実行');
    return users.filter(user => 
      user.name.toLowerCase().includes(filterText.toLowerCase())
    );
  }, [users, filterText]);
  
  // 関数をメモ化
  const handleUserSelect = useCallback((userId) => {
    setSelectedUser(users.find(user => user.id === userId));
  }, [users]);
  
  // ソートされたユーザーリスト
  const sortedUsers = useMemo(() => {
    return [...filteredUsers].sort((a, b) => a.name.localeCompare(b.name));
  }, [filteredUsers]);
  
  return (
    <div>
      <h2>ユーザー一覧</h2>
      <ul>
        {sortedUsers.map(user => (
          <li 
            key={user.id}
            onClick={() => handleUserSelect(user.id)}
            style={{ 
              cursor: 'pointer',
              backgroundColor: selectedUser?.id === user.id ? '#f0f0f0' : 'white'
            }}
          >
            {user.name}
          </li>
        ))}
      </ul>
      
      {selectedUser && (
        <div>
          <h3>選択されたユーザー</h3>
          <p>名前: {selectedUser.name}</p>
          <p>メール: {selectedUser.email}</p>
        </div>
      )}
    </div>
  );
}
```

### 3-7. エラーハンドリング

#### エラーバウンダリー

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    
    // エラーログの送信
    console.error('Error caught by boundary:', error, errorInfo);
    
    // 外部のエラー監視サービスに送信
    // logErrorToService(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>エラーが発生しました</h2>
          <p>申し訳ございませんが、問題が発生しました。</p>
          <button onClick={() => window.location.reload()}>
            ページを再読み込み
          </button>
          
          {process.env.NODE_ENV === 'development' && (
            <details style={{ whiteSpace: 'pre-wrap' }}>
              <summary>エラー詳細</summary>
              {this.state.error && this.state.error.toString()}
              <br />
              {this.state.errorInfo.componentStack}
            </details>
          )}
        </div>
      );
    }
    
    return this.props.children;
  }
}

// 使用例
function App() {
  return (
    <ErrorBoundary>
      <UserList />
    </ErrorBoundary>
  );
}
```

#### 関数コンポーネントでのエラーハンドリング

```jsx
import { useState, useEffect } from 'react';

function useErrorHandler() {
  const [error, setError] = useState(null);
  
  const handleError = (error) => {
    console.error('Error caught:', error);
    setError(error);
  };
  
  const clearError = () => {
    setError(null);
  };
  
  return { error, handleError, clearError };
}

function UserListWithErrorHandling() {
  const { error, handleError, clearError } = useErrorHandler();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const response = await fetch('/api/users');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        handleError(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUsers();
  }, [handleError]);
  
  if (error) {
    return (
      <div className="error-container">
        <h2>エラーが発生しました</h2>
        <p>{error.message}</p>
        <button onClick={clearError}>再試行</button>
      </div>
    );
  }
  
  if (loading) {
    return <div>読み込み中...</div>;
  }
  
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

### 3-8. コンポーネントのテスト

#### 基本的なテスト

```jsx
// UserCard.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import UserCard from './UserCard';

describe('UserCard', () => {
  const mockUser = {
    id: 1,
    name: '田中太郎',
    email: 'tanaka@example.com'
  };
  
  const mockOnEdit = jest.fn();
  const mockOnDelete = jest.fn();
  
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  test('ユーザー情報が正しく表示される', () => {
    render(
      <UserCard 
        user={mockUser} 
        onEdit={mockOnEdit} 
        onDelete={mockOnDelete} 
      />
    );
    
    expect(screen.getByText('田中太郎')).toBeInTheDocument();
    expect(screen.getByText('tanaka@example.com')).toBeInTheDocument();
  });
  
  test('編集ボタンがクリックされた時にonEditが呼ばれる', () => {
    render(
      <UserCard 
        user={mockUser} 
        onEdit={mockOnEdit} 
        onDelete={mockOnDelete} 
      />
    );
    
    const editButton = screen.getByText('編集');
    fireEvent.click(editButton);
    
    expect(mockOnEdit).toHaveBeenCalledWith(1);
  });
  
  test('削除ボタンがクリックされた時にonDeleteが呼ばれる', () => {
    render(
      <UserCard 
        user={mockUser} 
        onEdit={mockOnEdit} 
        onDelete={mockOnDelete} 
      />
    );
    
    const deleteButton = screen.getByText('削除');
    fireEvent.click(deleteButton);
    
    expect(mockOnDelete).toHaveBeenCalledWith(1);
  });
});
```

#### カスタムフックのテスト

```jsx
// useDataFetching.test.js
import { renderHook, waitFor } from '@testing-library/react';
import { useDataFetching } from './useDataFetching';

// fetchのモック
global.fetch = jest.fn();

describe('useDataFetching', () => {
  beforeEach(() => {
    fetch.mockClear();
  });
  
  test('データの取得に成功する', async () => {
    const mockData = [{ id: 1, name: 'テスト' }];
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockData
    });
    
    const { result } = renderHook(() => useDataFetching('/api/test'));
    
    expect(result.current.loading).toBe(true);
    expect(result.current.data).toBe(null);
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
    
    expect(result.current.data).toEqual(mockData);
    expect(result.current.error).toBe(null);
  });
  
  test('データの取得に失敗する', async () => {
    fetch.mockRejectedValueOnce(new Error('Network error'));
    
    const { result } = renderHook(() => useDataFetching('/api/test'));
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
    
    expect(result.current.error).toBe('Network error');
    expect(result.current.data).toBe(null);
  });
});
```

#### 統合テスト

```jsx
// UserList.integration.test.jsx
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import UserList from './UserList';

// APIのモック
jest.mock('./api', () => ({
  fetchUsers: jest.fn()
}));

import { fetchUsers } from './api';

describe('UserList Integration', () => {
  const mockUsers = [
    { id: 1, name: '田中太郎', email: 'tanaka@example.com' },
    { id: 2, name: '佐藤花子', email: 'sato@example.com' }
  ];
  
  beforeEach(() => {
    fetchUsers.mockClear();
  });
  
  test('ユーザーリストが正しく表示される', async () => {
    fetchUsers.mockResolvedValue(mockUsers);
    
    render(<UserList />);
    
    expect(screen.getByText('読み込み中...')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText('田中太郎')).toBeInTheDocument();
      expect(screen.getByText('佐藤花子')).toBeInTheDocument();
    });
  });
  
  test('エラー時にエラーメッセージが表示される', async () => {
    fetchUsers.mockRejectedValue(new Error('API Error'));
    
    render(<UserList />);
    
    await waitFor(() => {
      expect(screen.getByText('エラー: API Error')).toBeInTheDocument();
    });
  });
});
```

### 3-9. コンポーネントのベストプラクティス

#### 命名規則

```jsx
// ✅ 良い例：PascalCaseでコンポーネント名
function UserProfile() { }
function TodoItem() { }
function NavigationBar() { }

// ❌ 悪い例
function userProfile() { }
function todo_item() { }
function navBar() { }

// ✅ 良い例：ファイル名もPascalCase
// UserProfile.jsx
// TodoItem.jsx
// NavigationBar.jsx
```

#### 単一責任の原則

```jsx
// ✅ 良い例：1つの責任を持つコンポーネント
function UserAvatar({ user }) {
  return <img src={user.avatar} alt={user.name} />;
}

function UserName({ user }) {
  return <h3>{user.name}</h3>;
}

function UserEmail({ user }) {
  return <p>{user.email}</p>;
}

function UserCard({ user }) {
  return (
    <div className="user-card">
      <UserAvatar user={user} />
      <UserName user={user} />
      <UserEmail user={user} />
    </div>
  );
}

// ❌ 悪い例：複数の責任を持つコンポーネント
function UserCard({ user, onEdit, onDelete, onShare }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>編集</button>
      <button onClick={() => onDelete(user.id)}>削除</button>
      <button onClick={() => onShare(user.id)}>共有</button>
    </div>
  );
}
```

#### Propsの設計

```jsx
// ✅ 良い例：明確で型安全なprops
function Button({ 
  children, 
  variant = 'primary', 
  size = 'medium',
  disabled = false,
  onClick,
  ...restProps 
}) {
  const buttonClass = `btn btn-${variant} btn-${size}`;
  
  return (
    <button
      className={buttonClass}
      disabled={disabled}
      onClick={onClick}
      {...restProps}
    >
      {children}
    </button>
  );
}

// 使用例
<Button variant="danger" size="large" onClick={handleDelete}>
  削除
</Button>

// ❌ 悪い例：曖昧なprops
function Button({ 
  text, 
  style, 
  className, 
  onClick, 
  disabled 
}) {
  return (
    <button
      style={style}
      className={className}
      onClick={onClick}
      disabled={disabled}
    >
      {text}
    </button>
  );
}
```

#### パフォーマンスの考慮

```jsx
// ✅ 良い例：メモ化とコールバックの最適化
import React, { memo, useCallback } from 'react';

const UserCard = memo(({ user, onEdit, onDelete }) => {
  const handleEdit = useCallback(() => {
    onEdit(user.id);
  }, [user.id, onEdit]);
  
  const handleDelete = useCallback(() => {
    onDelete(user.id);
  }, [user.id, onDelete]);
  
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={handleEdit}>編集</button>
      <button onClick={handleDelete}>削除</button>
    </div>
  );
});

// ❌ 悪い例：毎回新しい関数が作成される
function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>編集</button>
      <button onClick={() => onDelete(user.id)}>削除</button>
    </div>
  );
}
```