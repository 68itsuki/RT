## 第2章：JSXと基本構文

### 2-1. JSXの基本概念

#### JSXとは何か？

JSX（JavaScript XML）は、JavaScript内でHTMLライクな構文を書ける拡張記法です。Reactでは、UIの構造を直感的に記述するために使用されます。

```jsx
// JSXの例
const element = <h1>Hello, world!</h1>;

// コンパイル後（実際のJavaScript）
const element = React.createElement('h1', null, 'Hello, world!');
```

#### JSXの利点

**1. 可読性の向上**
```jsx
// JSX（読みやすい）
const userCard = (
  <div className="user-card">
    <img src={user.avatar} alt={user.name} />
    <h2>{user.name}</h2>
    <p>{user.email}</p>
  </div>
);

// 従来のReact.createElement（読みにくい）
const userCard = React.createElement(
  'div',
  { className: 'user-card' },
  React.createElement('img', { src: user.avatar, alt: user.name }),
  React.createElement('h2', null, user.name),
  React.createElement('p', null, user.email)
);
```

**2. 開発効率の向上**
- HTMLの知識をそのまま活用できる
- エディタの補完機能が効く
- 構文エラーを早期に発見できる

### 2-2. JSXの基本構文

#### 要素の作成

```jsx
// 基本的な要素
const title = <h1>React入門</h1>;
const paragraph = <p>これは段落です</p>;
const link = <a href="https://react.dev">React公式サイト</a>;

// 複数の要素（Fragment使用）
const multipleElements = (
  <>
    <h1>タイトル</h1>
    <p>段落1</p>
    <p>段落2</p>
  </>
);
```

#### 属性の指定

```jsx
// HTML属性
const image = <img src="/logo.png" alt="ロゴ" />;
const input = <input type="text" placeholder="名前を入力" />;

// データ属性
const dataElement = <div data-testid="user-info">ユーザー情報</div>;

// カスタム属性
const customElement = <div customAttribute="value">カスタム要素</div>;
```

#### JSXの注意点

**1. 要素は1つの親タグで囲む**
```jsx
// ❌ 悪い例：複数の要素が並んでいる
function BadExample() {
  return (
    <h1>タイトル</h1>
    <p>段落</p>
  );
}

// ✅ 良い例：Fragmentで囲む
function GoodExample() {
  return (
    <>
      <h1>タイトル</h1>
      <p>段落</p>
    </>
  );
}

// ✅ 良い例：divで囲む
function GoodExample2() {
  return (
    <div>
      <h1>タイトル</h1>
      <p>段落</p>
    </div>
  );
}
```

**2. HTML属性名の違い**
```jsx
// HTML → JSX
// class → className
<div className="container">内容</div>

// for → htmlFor
<label htmlFor="name">名前</label>
<input id="name" type="text" />

// tabindex → tabIndex
<button tabIndex={0}>ボタン</button>

// readonly → readOnly
<input type="text" readOnly />

// maxlength → maxLength
<input type="text" maxLength={50} />
```

**3. スタイル属性**
```jsx
// インラインスタイルはオブジェクト形式
const style = {
  backgroundColor: 'blue',
  color: 'white',
  fontSize: '16px',
  padding: '10px'
};

const styledElement = <div style={style}>スタイル付き要素</div>;

// または直接記述
const inlineStyled = (
  <div style={{ 
    backgroundColor: 'red', 
    color: 'white' 
  }}>
    インラインスタイル
  </div>
);
```

### 2-3. JavaScriptの式の埋め込み

#### 基本的な式の埋め込み

```jsx
function UserGreeting({ user }) {
  const currentTime = new Date().toLocaleTimeString();
  const isMorning = new Date().getHours() < 12;
  
  return (
    <div>
      <h1>こんにちは、{user.name}さん！</h1>
      <p>現在時刻: {currentTime}</p>
      <p>{isMorning ? 'おはようございます' : 'こんにちは'}</p>
      <p>年齢: {2024 - user.birthYear}歳</p>
    </div>
  );
}
```

#### オブジェクトと配列の表示

```jsx
function UserProfile({ user }) {
  const userInfo = {
    name: user.name,
    email: user.email,
    role: user.role
  };
  
  const skills = ['JavaScript', 'React', 'Node.js'];
  
  return (
    <div>
      {/* オブジェクトの表示 */}
      <h2>ユーザー情報</h2>
      <ul>
        {Object.entries(userInfo).map(([key, value]) => (
          <li key={key}>
            <strong>{key}:</strong> {value}
          </li>
        ))}
      </ul>
      
      {/* 配列の表示 */}
      <h3>スキル</h3>
      <ul>
        {skills.map((skill, index) => (
          <li key={index}>{skill}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### 関数の呼び出し

```jsx
function UtilityFunctions() {
  const formatDate = (date) => {
    return new Date(date).toLocaleDateString('ja-JP');
  };
  
  const calculateTotal = (items) => {
    return items.reduce((sum, item) => sum + item.price, 0);
  };
  
  const items = [
    { name: '商品A', price: 1000 },
    { name: '商品B', price: 2000 }
  ];
  
  return (
    <div>
      <p>今日の日付: {formatDate(new Date())}</p>
      <p>合計金額: ¥{calculateTotal(items).toLocaleString()}</p>
    </div>
  );
}
```

### 2-4. 条件分岐とレンダリング

#### 三項演算子

```jsx
function ConditionalRendering({ user, isLoggedIn }) {
  return (
    <div>
      {/* 基本的な条件分岐 */}
      <h1>{isLoggedIn ? 'ようこそ！' : 'ログインしてください'}</h1>
      
      {/* 条件付きコンテンツ */}
      {isLoggedIn ? (
        <div>
          <p>こんにちは、{user.name}さん</p>
          <button>ログアウト</button>
        </div>
      ) : (
        <div>
          <p>ログインが必要です</p>
          <button>ログイン</button>
        </div>
      )}
    </div>
  );
}
```

#### 論理演算子（&&）

```jsx
function LogicalOperator({ user, showDetails }) {
  return (
    <div>
      {/* 条件が真の時のみ表示 */}
      {user && <p>ユーザー: {user.name}</p>}
      
      {/* 複数条件 */}
      {user && user.isAdmin && (
        <div>
          <h3>管理者メニュー</h3>
          <button>ユーザー管理</button>
          <button>設定</button>
        </div>
      )}
      
      {/* 詳細表示の切り替え */}
      {showDetails && (
        <div>
          <p>メール: {user.email}</p>
          <p>電話: {user.phone}</p>
        </div>
      )}
    </div>
  );
}
```

#### 複雑な条件分岐

```jsx
function ComplexConditional({ user, status, theme }) {
  const getStatusColor = (status) => {
    switch (status) {
      case 'active':
        return theme === 'dark' ? '#4CAF50' : '#2E7D32';
      case 'inactive':
        return theme === 'dark' ? '#F44336' : '#C62828';
      case 'pending':
        return theme === 'dark' ? '#FF9800' : '#EF6C00';
      default:
        return '#757575';
    }
  };
  
  const getStatusText = (status) => {
    const statusMap = {
      active: 'アクティブ',
      inactive: '非アクティブ',
      pending: '保留中'
    };
    return statusMap[status] || '不明';
  };
  
  return (
    <div>
      {user ? (
        <div style={{ color: getStatusColor(status) }}>
          <h2>{user.name}</h2>
          <p>ステータス: {getStatusText(status)}</p>
          {status === 'active' && <p>最終ログイン: {user.lastLogin}</p>}
        </div>
      ) : (
        <p>ユーザーが見つかりません</p>
      )}
    </div>
  );
}
```

### 2-5. ループ処理とリスト

#### map関数によるリスト表示

```jsx
function TodoList({ todos }) {
  return (
    <div>
      <h2>タスク一覧</h2>
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>
            <input 
              type="checkbox" 
              checked={todo.completed} 
            />
            <span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none' 
            }}>
              {todo.text}
            </span>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### フィルタリングとソート

```jsx
function UserList({ users, filter, sortBy }) {
  // フィルタリング
  const filteredUsers = users.filter(user => {
    if (filter === 'all') return true;
    if (filter === 'active') return user.status === 'active';
    if (filter === 'admin') return user.role === 'admin';
    return true;
  });
  
  // ソート
  const sortedUsers = [...filteredUsers].sort((a, b) => {
    if (sortBy === 'name') return a.name.localeCompare(b.name);
    if (sortBy === 'age') return a.age - b.age;
    if (sortBy === 'created') return new Date(b.createdAt) - new Date(a.createdAt);
    return 0;
  });
  
  return (
    <div>
      <h2>ユーザー一覧</h2>
      <table>
        <thead>
          <tr>
            <th>名前</th>
            <th>年齢</th>
            <th>ステータス</th>
            <th>作成日</th>
          </tr>
        </thead>
        <tbody>
          {sortedUsers.map((user) => (
            <tr key={user.id}>
              <td>{user.name}</td>
              <td>{user.age}</td>
              <td>
                <span className={`status-${user.status}`}>
                  {user.status}
                </span>
              </td>
              <td>{new Date(user.createdAt).toLocaleDateString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

#### グループ化とカテゴリ表示

```jsx
function ProductList({ products }) {
  // カテゴリごとにグループ化
  const groupedProducts = products.reduce((groups, product) => {
    const category = product.category;
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(product);
    return groups;
  }, {});
  
  return (
    <div>
      <h2>商品一覧</h2>
      {Object.entries(groupedProducts).map(([category, categoryProducts]) => (
        <div key={category}>
          <h3>{category}</h3>
          <div className="product-grid">
            {categoryProducts.map((product) => (
              <div key={product.id} className="product-card">
                <img src={product.image} alt={product.name} />
                <h4>{product.name}</h4>
                <p>¥{product.price.toLocaleString()}</p>
                <button>カートに追加</button>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}
```

### 2-6. イベントハンドリング

#### 基本的なイベント処理

```jsx
function EventHandling() {
  const handleClick = () => {
    alert('ボタンがクリックされました！');
  };
  
  const handleMouseEnter = (event) => {
    event.target.style.backgroundColor = 'yellow';
  };
  
  const handleMouseLeave = (event) => {
    event.target.style.backgroundColor = 'white';
  };
  
  const handleInputChange = (event) => {
    console.log('入力値:', event.target.value);
  };
  
  const handleFormSubmit = (event) => {
    event.preventDefault();
    console.log('フォームが送信されました');
  };
  
  return (
    <div>
      <button onClick={handleClick}>クリック</button>
      
      <div 
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        style={{ padding: '10px', border: '1px solid black' }}
      >
        マウスオーバーしてください
      </div>
      
      <input 
        type="text" 
        onChange={handleInputChange}
        placeholder="入力してください"
      />
      
      <form onSubmit={handleFormSubmit}>
        <input type="text" placeholder="フォーム入力" />
        <button type="submit">送信</button>
      </form>
    </div>
  );
}
```

#### パラメータ付きイベントハンドラー

```jsx
function ParameterizedEvents({ items }) {
  const handleItemClick = (itemId, itemName) => {
    console.log(`アイテム ${itemId}: ${itemName} がクリックされました`);
  };
  
  const handleDelete = (itemId) => {
    if (window.confirm('本当に削除しますか？')) {
      console.log(`アイテム ${itemId} を削除します`);
    }
  };
  
  return (
    <div>
      <h2>アイテム一覧</h2>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            <span 
              onClick={() => handleItemClick(item.id, item.name)}
              style={{ cursor: 'pointer' }}
            >
              {item.name}
            </span>
            <button 
              onClick={() => handleDelete(item.id)}
              style={{ marginLeft: '10px' }}
            >
              削除
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### イベントオブジェクトの活用

```jsx
function EventObjectHandling() {
  const handleKeyPress = (event) => {
    if (event.key === 'Enter') {
      console.log('Enterキーが押されました');
    }
  };
  
  const handleMouseMove = (event) => {
    const { clientX, clientY } = event;
    console.log(`マウス位置: (${clientX}, ${clientY})`);
  };
  
  const handleScroll = (event) => {
    const { scrollTop, scrollHeight, clientHeight } = event.target;
    const scrollPercentage = (scrollTop / (scrollHeight - clientHeight)) * 100;
    console.log(`スクロール位置: ${scrollPercentage.toFixed(1)}%`);
  };
  
  return (
    <div>
      <input 
        type="text" 
        onKeyPress={handleKeyPress}
        placeholder="Enterキーを押してください"
      />
      
      <div 
        onMouseMove={handleMouseMove}
        style={{ 
          height: '200px', 
          border: '1px solid black',
          margin: '10px 0'
        }}
      >
        マウスを動かしてください
      </div>
      
      <div 
        onScroll={handleScroll}
        style={{ 
          height: '100px', 
          overflow: 'auto',
          border: '1px solid black'
        }}
      >
        {Array.from({ length: 50 }, (_, i) => (
          <p key={i}>スクロール可能なコンテンツ {i + 1}</p>
        ))}
      </div>
    </div>
  );
}
```

### 2-7. フォーム処理

#### 基本的なフォーム

```jsx
function BasicForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  
  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('送信データ:', formData);
    // APIにデータを送信する処理
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="name">名前:</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          required
        />
      </div>
      
      <div>
        <label htmlFor="email">メールアドレス:</label>
        <input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          required
        />
      </div>
      
      <div>
        <label htmlFor="message">メッセージ:</label>
        <textarea
          id="message"
          name="message"
          value={formData.message}
          onChange={handleChange}
          rows="4"
        />
      </div>
      
      <button type="submit">送信</button>
    </form>
  );
}
```

#### 複雑なフォーム（バリデーション付き）

```jsx
function AdvancedForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    age: '',
    interests: []
  });
  
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const validateField = (name, value) => {
    switch (name) {
      case 'username':
        if (!value) return 'ユーザー名は必須です';
        if (value.length < 3) return 'ユーザー名は3文字以上で入力してください';
        return '';
      
      case 'email':
        if (!value) return 'メールアドレスは必須です';
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(value)) return '有効なメールアドレスを入力してください';
        return '';
      
      case 'password':
        if (!value) return 'パスワードは必須です';
        if (value.length < 8) return 'パスワードは8文字以上で入力してください';
        return '';
      
      case 'confirmPassword':
        if (value !== formData.password) return 'パスワードが一致しません';
        return '';
      
      case 'age':
        if (value && (value < 0 || value > 120)) return '有効な年齢を入力してください';
        return '';
      
      default:
        return '';
    }
  };
  
  const handleChange = (event) => {
    const { name, value, type, checked } = event.target;
    
    let newValue = value;
    if (type === 'checkbox') {
      const currentInterests = formData.interests;
      newValue = checked
        ? [...currentInterests, value]
        : currentInterests.filter(interest => interest !== value);
    }
    
    setFormData(prev => ({
      ...prev,
      [name]: newValue
    }));
    
    // バリデーション
    const error = validateField(name, newValue);
    setErrors(prev => ({
      ...prev,
      [name]: error
    }));
  };
  
  const handleBlur = (event) => {
    const { name } = event.target;
    setTouched(prev => ({
      ...prev,
      [name]: true
    }));
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    
    // 全フィールドのバリデーション
    const newErrors = {};
    Object.keys(formData).forEach(key => {
      const error = validateField(key, formData[key]);
      if (error) newErrors[key] = error;
    });
    
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      console.log('フォーム送信:', formData);
      // 送信処理
    }
  };
  
  const interests = ['プログラミング', 'デザイン', '音楽', 'スポーツ', '読書'];
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="username">ユーザー名:</label>
        <input
          type="text"
          id="username"
          name="username"
          value={formData.username}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.username && errors.username && (
          <span style={{ color: 'red' }}>{errors.username}</span>
        )}
      </div>
      
      <div>
        <label htmlFor="email">メールアドレス:</label>
        <input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.email && errors.email && (
          <span style={{ color: 'red' }}>{errors.email}</span>
        )}
      </div>
      
      <div>
        <label htmlFor="password">パスワード:</label>
        <input
          type="password"
          id="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.password && errors.password && (
          <span style={{ color: 'red' }}>{errors.password}</span>
        )}
      </div>
      
      <div>
        <label htmlFor="confirmPassword">パスワード確認:</label>
        <input
          type="password"
          id="confirmPassword"
          name="confirmPassword"
          value={formData.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.confirmPassword && errors.confirmPassword && (
          <span style={{ color: 'red' }}>{errors.confirmPassword}</span>
        )}
      </div>
      
      <div>
        <label htmlFor="age">年齢:</label>
        <input
          type="number"
          id="age"
          name="age"
          value={formData.age}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.age && errors.age && (
          <span style={{ color: 'red' }}>{errors.age}</span>
        )}
      </div>
      
      <div>
        <label>興味のある分野:</label>
        {interests.map(interest => (
          <label key={interest}>
            <input
              type="checkbox"
              name="interests"
              value={interest}
              checked={formData.interests.includes(interest)}
              onChange={handleChange}
            />
            {interest}
          </label>
        ))}
      </div>
      
      <button type="submit">登録</button>
    </form>
  );
}
```

### 2-8. スタイリング

#### インラインスタイル

```jsx
function InlineStyling() {
  const containerStyle = {
    padding: '20px',
    backgroundColor: '#f5f5f5',
    borderRadius: '8px',
    boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
  };
  
  const buttonStyle = {
    backgroundColor: '#007bff',
    color: 'white',
    border: 'none',
    padding: '10px 20px',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '16px'
  };
  
  const buttonHoverStyle = {
    ...buttonStyle,
    backgroundColor: '#0056b3'
  };
  
  const [isHovered, setIsHovered] = useState(false);
  
  return (
    <div style={containerStyle}>
      <h2 style={{ color: '#333', marginBottom: '20px' }}>
        インラインスタイルの例
      </h2>
      
      <button
        style={isHovered ? buttonHoverStyle : buttonStyle}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        ホバーしてください
      </button>
    </div>
  );
}
```

#### CSSクラスとモジュール

```jsx
// styles/Button.module.css
.button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.3s;
}

.button:hover {
  background-color: #0056b3;
}

.button.primary {
  background-color: #28a745;
}

.button.primary:hover {
  background-color: #1e7e34;
}

.button.danger {
  background-color: #dc3545;
}

.button.danger:hover {
  background-color: #c82333;
}

// Button.jsx
import styles from './Button.module.css';

function Button({ children, variant = 'default', ...props }) {
  const buttonClass = `${styles.button} ${styles[variant] || ''}`;
  
  return (
    <button className={buttonClass} {...props}>
      {children}
    </button>
  );
}

// 使用例
function ButtonExample() {
  return (
    <div>
      <Button>デフォルトボタン</Button>
      <Button variant="primary">プライマリボタン</Button>
      <Button variant="danger">削除ボタン</Button>
    </div>
  );
}
```

#### 条件付きスタイリング

```jsx
function ConditionalStyling({ status, isActive, theme }) {
  const getStatusStyle = (status) => {
    const baseStyle = {
      padding: '8px 16px',
      borderRadius: '4px',
      fontSize: '14px',
      fontWeight: 'bold'
    };
    
    switch (status) {
      case 'success':
        return {
          ...baseStyle,
          backgroundColor: '#d4edda',
          color: '#155724',
          border: '1px solid #c3e6cb'
        };
      case 'error':
        return {
          ...baseStyle,
          backgroundColor: '#f8d7da',
          color: '#721c24',
          border: '1px solid #f5c6cb'
        };
      case 'warning':
        return {
          ...baseStyle,
          backgroundColor: '#fff3cd',
          color: '#856404',
          border: '1px solid #ffeaa7'
        };
      default:
        return {
          ...baseStyle,
          backgroundColor: '#d1ecf1',
          color: '#0c5460',
          border: '1px solid #bee5eb'
        };
    }
  };
  
  const cardStyle = {
    padding: '20px',
    borderRadius: '8px',
    border: '1px solid #ddd',
    backgroundColor: theme === 'dark' ? '#333' : '#fff',
    color: theme === 'dark' ? '#fff' : '#333',
    opacity: isActive ? 1 : 0.6,
    transition: 'all 0.3s ease'
  };
  
  return (
    <div style={cardStyle}>
      <div style={getStatusStyle(status)}>
        ステータス: {status}
      </div>
      <p>このカードは{isActive ? 'アクティブ' : '非アクティブ'}です</p>
    </div>
  );
}
```

### 2-9. パフォーマンス最適化

#### 不要な再レンダリングの防止

```jsx
import React, { memo, useMemo, useCallback } from 'react';

// メモ化されたコンポーネント
const ExpensiveComponent = memo(({ data, onUpdate }) => {
  console.log('ExpensiveComponent rendered');
  
  // 重い計算をメモ化
  const processedData = useMemo(() => {
    console.log('Processing data...');
    return data.map(item => ({
      ...item,
      processed: item.value * 2
    }));
  }, [data]);
  
  return (
    <div>
      {processedData.map(item => (
        <div key={item.id}>
          {item.name}: {item.processed}
        </div>
      ))}
      <button onClick={onUpdate}>更新</button>
    </div>
  );
});

// 親コンポーネント
function ParentComponent() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState([
    { id: 1, name: 'アイテム1', value: 10 },
    { id: 2, name: 'アイテム2', value: 20 }
  ]);
  
  // 関数をメモ化
  const handleUpdate = useCallback(() => {
    console.log('Updating data...');
    setData(prev => prev.map(item => ({
      ...item,
      value: item.value + 1
    })));
  }, []);
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        カウント増加
      </button>
      
      <ExpensiveComponent 
        data={data} 
        onUpdate={handleUpdate} 
      />
    </div>
  );
}
```

#### リストの最適化

```jsx
function OptimizedList({ items }) {
  // 仮想化されたリスト（大量のデータ用）
  const VirtualizedList = ({ items, itemHeight = 50, containerHeight = 400 }) => {
    const [scrollTop, setScrollTop] = useState(0);
    
    const visibleItems = useMemo(() => {
      const startIndex = Math.floor(scrollTop / itemHeight);
      const endIndex = Math.min(
        startIndex + Math.ceil(containerHeight / itemHeight),
        items.length
      );
      
      return items.slice(startIndex, endIndex).map((item, index) => ({
        ...item,
        index: startIndex + index
      }));
    }, [items, scrollTop, itemHeight, containerHeight]);
    
    const totalHeight = items.length * itemHeight;
    
    return (
      <div
        style={{ height: containerHeight, overflow: 'auto' }}
        onScroll={(e) => setScrollTop(e.target.scrollTop)}
      >
        <div style={{ height: totalHeight, position: 'relative' }}>
          {visibleItems.map(item => (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: item.index * itemHeight,
                height: itemHeight,
                width: '100%',
                borderBottom: '1px solid #eee',
                padding: '10px'
              }}
            >
              {item.name}
            </div>
          ))}
        </div>
      </div>
    );
  };
  
  return (
    <div>
      <h3>最適化されたリスト</h3>
      <VirtualizedList items={items} />
    </div>
  );
}
```