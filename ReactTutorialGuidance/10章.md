## 第10章：状態管理の拡張（Context API・useReducer・Store）

### 10-1. 状態管理の基本概念

#### ローカルステート vs グローバルステート

**ローカルステート（useState）**
- そのコンポーネント内でのみ使用される状態
- 例：フォームの入力値、モーダルの開閉状態

```jsx
function TodoForm() {
  const [input, setInput] = useState(''); // ローカルステート
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  return (
    <form>
      <input 
        value={input} 
        onChange={(e) => setInput(e.target.value)} 
      />
    </form>
  );
}
```

**グローバルステート（Context/Store）**
- 複数のコンポーネント間で共有される状態
- 例：ユーザー情報、テーマ設定、ショッピングカート

```jsx
// ユーザー情報は複数の画面で使われるためグローバルステート
const UserContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Header />
      <Profile />
      <Settings />
    </UserContext.Provider>
  );
}
```

**判断基準**
- その状態を**2つ以上のコンポーネント**で使う → グローバルステート
- その状態が**アプリ全体**に関わる → グローバルステート
- その状態が**1つのコンポーネント**のみで使う → ローカルステート

#### 状態のリフトアップ（State Lifting）

共通の親コンポーネントに状態を移動させる手法です。

```jsx
// ❌ 悪い例：兄弟コンポーネント間で状態を共有できない
function TemperatureInput() {
  const [temperature, setTemperature] = useState('');
  return <input value={temperature} onChange={setTemperature} />;
}

function TemperatureDisplay() {
  const [temperature, setTemperature] = useState(''); // 別の状態
  return <p>{temperature}°C</p>;
}

// ✅ 良い例：親で状態を管理
function TemperatureCalculator() {
  const [temperature, setTemperature] = useState('');
  
  return (
    <div>
      <TemperatureInput 
        value={temperature} 
        onChange={setTemperature} 
      />
      <TemperatureDisplay temperature={temperature} />
    </div>
  );
}
```

#### Props Drilling問題

深い階層のコンポーネントにpropsを渡す際に発生する問題です。

```jsx
// ❌ Props Drilling問題の例
function App() {
  const [user, setUser] = useState(null);
  
  return (
    <div>
      <Header user={user} />
      <Main>
        <Sidebar user={user} />
        <Content>
          <Article user={user} />
        </Content>
      </Main>
    </div>
  );
}

// ✅ Context APIで解決
const UserContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <div>
        <Header />
        <Main>
          <Sidebar />
          <Content>
            <Article />
          </Content>
        </Main>
      </div>
    </UserContext.Provider>
  );
}

function Article() {
  const { user } = useContext(UserContext); // 直接取得
  return <div>{user.name}</div>;
}
```

#### 単一データフローの原則

Reactの状態管理の基本思想：
1. **状態は上から下に流れる**（親→子）
2. **イベントは下から上に流れる**（子→親）
3. **状態の更新は一箇所で行う**

```jsx
// 単一データフローの例
function TodoApp() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, completed: false }]);
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  return (
    <div>
      <TodoForm onAdd={addTodo} />
      <TodoList todos={todos} onToggle={toggleTodo} />
    </div>
  );
}
```

### 10-2. Context APIの実践的な使い方

#### 複数のContextの組み合わせ

```jsx
// ユーザー情報のContext
const UserContext = createContext();
const ThemeContext = createContext();
const LanguageContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [language, setLanguage] = useState('ja');
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <LanguageContext.Provider value={{ language, setLanguage }}>
          <Header />
          <Main />
          <Footer />
        </LanguageContext.Provider>
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// カスタムフックで使いやすくする
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 使用例
function Profile() {
  const { user, setUser } = useUser();
  const { theme, setTheme } = useTheme();
  
  return (
    <div className={`profile ${theme}`}>
      <h2>{user.name}</h2>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        テーマ切り替え
      </button>
    </div>
  );
}
```

#### Contextのパフォーマンス問題と解決策

**問題：不要な再レンダリング**

```jsx
// ❌ 問題のある例：値が変わらなくても再レンダリング
const AppContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  const [count, setCount] = useState(0);
  
  return (
    <AppContext.Provider value={{ user, setUser, count, setCount }}>
      <Header />
      <Main />
    </AppContext.Provider>
  );
}

function Header() {
  const { user } = useContext(AppContext);
  console.log('Header rendered'); // countが変わっても再レンダリングされる
  
  return <header>{user?.name}</header>;
}
```

**解決策1：Contextを分割**

```jsx
// ✅ 解決策：関連する状態ごとにContextを分割
const UserContext = createContext();
const CounterContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  const [count, setCount] = useState(0);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <CounterContext.Provider value={{ count, setCount }}>
        <Header />
        <Main />
      </CounterContext.Provider>
    </UserContext.Provider>
  );
}
```

**解決策2：useMemoで値を最適化**

```jsx
function App() {
  const [user, setUser] = useState(null);
  const [count, setCount] = useState(0);
  
  const userValue = useMemo(() => ({ user, setUser }), [user]);
  const counterValue = useMemo(() => ({ count, setCount }), [count]);
  
  return (
    <UserContext.Provider value={userValue}>
      <CounterContext.Provider value={counterValue}>
        <Header />
        <Main />
      </CounterContext.Provider>
    </UserContext.Provider>
  );
}
```

#### カスタムフックとの組み合わせ

```jsx
// カスタムフックでContextをラップ
function useUserContext() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUserContext must be used within UserProvider');
  }
  return context;
}

function useAuth() {
  const { user, setUser } = useUserContext();
  
  const login = useCallback(async (email, password) => {
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      const userData = await response.json();
      setUser(userData);
    } catch (error) {
      console.error('Login failed:', error);
    }
  }, [setUser]);
  
  const logout = useCallback(() => {
    setUser(null);
  }, [setUser]);
  
  return {
    user,
    isAuthenticated: !!user,
    login,
    logout
  };
}

// 使用例
function LoginForm() {
  const { login } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    login(email, password);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="email" 
        value={email} 
        onChange={(e) => setEmail(e.target.value)} 
      />
      <input 
        type="password" 
        value={password} 
        onChange={(e) => setPassword(e.target.value)} 
      />
      <button type="submit">ログイン</button>
    </form>
  );
}
```

### 10-3. useReducerの詳細

#### 複雑な状態更新ロジック

```jsx
// フォームデータの管理例
const formReducer = (state, action) => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        [action.field]: action.value
      };
    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.errors
      };
    case 'RESET':
      return {
        name: '',
        email: '',
        password: '',
        errors: {}
      };
    default:
      return state;
  }
};

function RegistrationForm() {
  const [state, dispatch] = useReducer(formReducer, {
    name: '',
    email: '',
    password: '',
    errors: {}
  });
  
  const handleChange = (field, value) => {
    dispatch({ type: 'SET_FIELD', field, value });
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // バリデーション
    const errors = {};
    if (!state.name) errors.name = '名前は必須です';
    if (!state.email) errors.email = 'メールアドレスは必須です';
    
    if (Object.keys(errors).length > 0) {
      dispatch({ type: 'SET_ERRORS', errors });
      return;
    }
    
    // 送信処理
    try {
      await fetch('/api/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(state)
      });
      dispatch({ type: 'RESET' });
    } catch (error) {
      dispatch({ type: 'SET_ERRORS', errors: { submit: '登録に失敗しました' } });
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={state.name}
        onChange={(e) => handleChange('name', e.target.value)}
        placeholder="名前"
      />
      {state.errors.name && <span>{state.errors.name}</span>}
      
      <input
        type="email"
        value={state.email}
        onChange={(e) => handleChange('email', e.target.value)}
        placeholder="メールアドレス"
      />
      {state.errors.email && <span>{state.errors.email}</span>}
      
      <button type="submit">登録</button>
    </form>
  );
}
```

#### ミドルウェアパターン

```jsx
// ログ出力ミドルウェア
const loggerMiddleware = (reducer) => {
  return (state, action) => {
    console.log('Previous State:', state);
    console.log('Action:', action);
    
    const newState = reducer(state, action);
    
    console.log('New State:', newState);
    return newState;
  };
};

// 非同期処理ミドルウェア
const asyncMiddleware = (reducer) => {
  return (state, action) => {
    if (action.type === 'ASYNC_ACTION') {
      // 非同期処理を実行
      action.asyncFunction().then(result => {
        action.dispatch({ type: 'ASYNC_SUCCESS', payload: result });
      });
      return { ...state, loading: true };
    }
    return reducer(state, action);
  };
};

// 使用例
const enhancedReducer = asyncMiddleware(loggerMiddleware(counterReducer));
const [state, dispatch] = useReducer(enhancedReducer, { count: 0, loading: false });
```

#### Reducerのテスト方法

```jsx
// Reducerのテスト（純粋関数なのでテストしやすい）
describe('counterReducer', () => {
  it('should increment count', () => {
    const initialState = { count: 0 };
    const action = { type: 'INCREMENT' };
    const newState = counterReducer(initialState, action);
    
    expect(newState.count).toBe(1);
  });
  
  it('should decrement count', () => {
    const initialState = { count: 5 };
    const action = { type: 'DECREMENT' };
    const newState = counterReducer(initialState, action);
    
    expect(newState.count).toBe(4);
  });
  
  it('should return same state for unknown action', () => {
    const initialState = { count: 0 };
    const action = { type: 'UNKNOWN' };
    const newState = counterReducer(initialState, action);
    
    expect(newState).toBe(initialState);
  });
});
```

### 10-4. 実務での状態管理パターン

#### フォーム状態の管理

```jsx
// react-hook-formとの連携
import { useForm } from 'react-hook-form';

function ContactForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();
  
  const onSubmit = (data) => {
    console.log(data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('name', { required: '名前は必須です' })}
        placeholder="名前"
      />
      {errors.name && <span>{errors.name.message}</span>}
      
      <input
        {...register('email', { 
          required: 'メールアドレスは必須です',
          pattern: {
            value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
            message: '有効なメールアドレスを入力してください'
          }
        })}
        placeholder="メールアドレス"
      />
      {errors.email && <span>{errors.email.message}</span>}
      
      <button type="submit">送信</button>
    </form>
  );
}
```

#### APIデータのキャッシュ

```jsx
// SWRを使ったデータフェッチング
import useSWR from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UserProfile({ userId }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
      refreshInterval: 30000 // 30秒ごとに更新
    }
  );
  
  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラーが発生しました</div>;
  if (!data) return <div>データが見つかりません</div>;
  
  return (
    <div>
      <h2>{data.name}</h2>
      <p>{data.email}</p>
    </div>
  );
}
```

#### 楽観的更新

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = async (text) => {
    // 楽観的更新：先にUIを更新
    const newTodo = { id: Date.now(), text, completed: false };
    setTodos(prev => [...prev, newTodo]);
    
    try {
      // 実際のAPI呼び出し
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      
      const savedTodo = await response.json();
      
      // 成功時：サーバーからの正しいデータで更新
      setTodos(prev => 
        prev.map(todo => 
          todo.id === newTodo.id ? savedTodo : todo
        )
      );
    } catch (error) {
      // 失敗時：元に戻す
      setTodos(prev => prev.filter(todo => todo.id !== newTodo.id));
      alert('追加に失敗しました');
    }
  };
  
  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>{todo.text}</div>
      ))}
      <button onClick={() => addTodo('新しいタスク')}>
        タスク追加
      </button>
    </div>
  );
}
```

#### エラー状態の管理

```jsx
// loading/error/dataの3つの状態パターン
function DataComponent() {
  const [state, setState] = useState({
    data: null,
    loading: false,
    error: null
  });
  
  const fetchData = async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const response = await fetch('/api/data');
      const data = await response.json();
      
      setState({
        data,
        loading: false,
        error: null
      });
    } catch (error) {
      setState({
        data: null,
        loading: false,
        error: error.message
      });
    }
  };
  
  useEffect(() => {
    fetchData();
  }, []);
  
  if (state.loading) return <div>読み込み中...</div>;
  if (state.error) return <div>エラー: {state.error}</div>;
  if (!state.data) return <div>データがありません</div>;
  
  return (
    <div>
      <h2>{state.data.title}</h2>
      <p>{state.data.description}</p>
    </div>
  );
}
```

### 10-5. 状態管理ライブラリの比較と選択基準

#### Zustand

**特徴：**
- 軽量で学習コストが低い
- Hooksと親和性が高い
- TypeScript対応が優秀
- ボイラープレートが少ない

```jsx
import { create } from 'zustand';

// 基本的なStore
const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));

// 使用例
function Counter() {
  const { count, increment, decrement } = useCounterStore();
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}

// 複雑なStore
const useUserStore = create((set, get) => ({
  user: null,
  isAuthenticated: false,
  
  login: async (email, password) => {
    set({ isAuthenticated: false });
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      const user = await response.json();
      set({ user, isAuthenticated: true });
    } catch (error) {
      set({ user: null, isAuthenticated: false });
      throw error;
    }
  },
  
  logout: () => {
    set({ user: null, isAuthenticated: false });
  },
  
  updateProfile: (updates) => {
    const { user } = get();
    set({ user: { ...user, ...updates } });
  }
}));
```

#### Redux Toolkit

**特徴：**
- 業界標準
- 強力な開発者ツール
- 大規模アプリケーションに適している
- イミュータブルな更新が強制される

```jsx
import { createSlice, configureStore } from '@reduxjs/toolkit';

// Sliceの作成
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

// Storeの設定
const store = configureStore({
  reducer: {
    counter: counterSlice.reducer
  }
});

// 使用例
import { useSelector, useDispatch } from 'react-redux';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(counterSlice.actions.increment())}>
        +
      </button>
      <button onClick={() => dispatch(counterSlice.actions.decrement())}>
        -
      </button>
    </div>
  );
}
```

#### 選択基準

| ライブラリ | 適しているケース | 学習コスト | パフォーマンス |
|------------|------------------|------------|----------------|
| **useState + Context** | 小〜中規模アプリ | 低 | 中 |
| **Zustand** | 中規模アプリ、Hooks重視 | 低 | 高 |
| **Redux Toolkit** | 大規模アプリ、チーム開発 | 中 | 高 |
| **Recoil** | React特化、細かい制御 | 中 | 高 |

### 10-6. パフォーマンス最適化

#### メモ化の活用

```jsx
import React, { memo, useMemo, useCallback } from 'react';

// React.memo：コンポーネントのメモ化
const ExpensiveComponent = memo(({ data, onUpdate }) => {
  console.log('ExpensiveComponent rendered');
  
  return (
    <div>
      {data.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
      <button onClick={onUpdate}>更新</button>
    </div>
  );
});

// useMemo：値のメモ化
function UserList({ users, filter }) {
  const filteredUsers = useMemo(() => {
    console.log('Filtering users...');
    return users.filter(user => user.name.includes(filter));
  }, [users, filter]);
  
  return (
    <ul>
      {filteredUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// useCallback：関数のメモ化
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  const handleUpdate = useCallback(() => {
    console.log('Updating...');
    setCount(prev => prev + 1);
  }, []); // 依存配列が空なので、関数は再作成されない
  
  return (
    <div>
      <p>Count: {count}</p>
      <ExpensiveComponent 
        data={[{ id: 1, name: 'Test' }]} 
        onUpdate={handleUpdate} 
      />
    </div>
  );
}
```

#### 状態の正規化

```jsx
// ❌ 悪い例：ネストしたデータ
const badState = {
  posts: [
    {
      id: 1,
      title: '投稿1',
      author: {
        id: 1,
        name: '田中',
        email: 'tanaka@example.com'
      },
      comments: [
        {
          id: 1,
          text: 'コメント1',
          user: {
            id: 2,
            name: '佐藤'
          }
        }
      ]
    }
  ]
};

// ✅ 良い例：正規化されたデータ
const normalizedState = {
  posts: {
    byId: {
      1: { id: 1, title: '投稿1', authorId: 1, commentIds: [1] }
    },
    allIds: [1]
  },
  users: {
    byId: {
      1: { id: 1, name: '田中', email: 'tanaka@example.com' },
      2: { id: 2, name: '佐藤' }
    },
    allIds: [1, 2]
  },
  comments: {
    byId: {
      1: { id: 1, text: 'コメント1', userId: 2, postId: 1 }
    },
    allIds: [1]
  }
};

// セレクター関数
const selectPost = (state, postId) => {
  const post = state.posts.byId[postId];
  if (!post) return null;
  
  return {
    ...post,
    author: state.users.byId[post.authorId],
    comments: post.commentIds.map(id => ({
      ...state.comments.byId[id],
      user: state.users.byId[state.comments.byId[id].userId]
    }))
  };
};
```

#### 選択的な再レンダリング

```jsx
// コンテキストの分割による最適化
const UserContext = createContext();
const ThemeContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <Header />
        <Main />
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// ユーザー情報のみを必要とするコンポーネント
function UserProfile() {
  const { user } = useContext(UserContext);
  console.log('UserProfile rendered');
  
  return <div>{user?.name}</div>;
}

// テーマのみを必要とするコンポーネント
function ThemeToggle() {
  const { theme, setTheme } = useContext(ThemeContext);
  console.log('ThemeToggle rendered');
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      {theme}
    </button>
  );
}
```

### 10-7. デバッグとテスト

#### Redux DevToolsの使い方

```jsx
// Redux DevToolsの設定
import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production'
});

// ブラウザでRedux DevToolsを開く
// 1. F12で開発者ツールを開く
// 2. Reduxタブを選択
// 3. アクションの履歴を確認
// 4. 状態の変化を時系列で追跡
```

#### 状態管理のテスト戦略

```jsx
// Reducerのテスト
describe('userReducer', () => {
  it('should handle LOGIN_SUCCESS', () => {
    const initialState = { user: null, isAuthenticated: false };
    const user = { id: 1, name: '田中' };
    const action = { type: 'LOGIN_SUCCESS', payload: user };
    
    const newState = userReducer(initialState, action);
    
    expect(newState.user).toEqual(user);
    expect(newState.isAuthenticated).toBe(true);
  });
});

// カスタムフックのテスト
import { renderHook, act } from '@testing-library/react-hooks';

describe('useAuth', () => {
  it('should login user', async () => {
    const { result } = renderHook(() => useAuth());
    
    await act(async () => {
      await result.current.login('test@example.com', 'password');
    });
    
    expect(result.current.isAuthenticated).toBe(true);
  });
});

// コンポーネントのテスト
import { render, screen, fireEvent } from '@testing-library/react';

describe('LoginForm', () => {
  it('should submit form with user data', () => {
    const mockLogin = jest.fn();
    render(<LoginForm onLogin={mockLogin} />);
    
    fireEvent.change(screen.getByPlaceholderText('メールアドレス'), {
      target: { value: 'test@example.com' }
    });
    
    fireEvent.change(screen.getByPlaceholderText('パスワード'), {
      target: { value: 'password' }
    });
    
    fireEvent.click(screen.getByText('ログイン'));
    
    expect(mockLogin).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password'
    });
  });
});
```

#### デバッグ時のベストプラクティス

```jsx
// デバッグ用のカスタムフック
function useDebugState(state, label = 'State') {
  useEffect(() => {
    console.log(`${label}:`, state);
  }, [state, label]);
}

// 使用例
function MyComponent() {
  const [user, setUser] = useState(null);
  useDebugState(user, 'User State');
  
  // 状態の変化を追跡
  const handleLogin = (userData) => {
    console.log('Login attempt:', userData);
    setUser(userData);
  };
  
  return <div>{/* コンポーネントの内容 */}</div>;
}

// 開発環境でのみログを出力
const debugLog = (message, data) => {
  if (process.env.NODE_ENV === 'development') {
    console.log(`[DEBUG] ${message}:`, data);
  }
};

// エラーバウンダリー
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>エラーが発生しました</h1>;
    }
    
    return this.props.children;
  }
}
```

---
